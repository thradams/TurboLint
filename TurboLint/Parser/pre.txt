















































typedef long long __int64;

typedef int  __int32;

typedef short wchar_t;

typedef char __int8;

typedef short __int16;

























































































































    















    

    





        





            

        

    











































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    



    

    

    

    



    

    













































































































































































































































































































































































































































































     

    











































































 













































 

 















































































































































































































































































































































































































































    

    



        typedef unsigned int uintptr_t;

    







    

    



        typedef char* va_list;

    











    























    

    

















    



    

    

    





















































    



































    



    







 









    







































    

















        

    







    













        

    



















    















    

    











    



















    















    











    







    







      

    

















    typedef unsigned int     size_t;

    typedef int              ptrdiff_t;

    typedef int              intptr_t;











    typedef _Bool __vcrt_bool;









    







    







    









    

    typedef unsigned short wchar_t;







    





        

    











    











    





















    





        

    















    

        

    























    void  __security_init_cookie(void);



    

        void  __security_check_cookie( uintptr_t _StackCookie);

          void  __report_gsfailure(void);

    







extern uintptr_t __security_cookie;





    

    

    





 









 



















    









        

    











    







    









        

    











    











    











    













    





























    





        

    











    











    











    





























    typedef _Bool __crt_bool;























    































    





















    





















        

    







    







    

        

    





































     void  _invalid_parameter(

         wchar_t const*,

         wchar_t const*,

         wchar_t const*,

         unsigned int,

         uintptr_t

        );





 void  _invalid_parameter_noinfo(void);

   void  _invalid_parameter_noinfo_noreturn(void);



 

 void  _invoke_watson(

     wchar_t const*,

     wchar_t const*,

     wchar_t const*,

     unsigned int,

     uintptr_t);





    

        

    

































    





        

    





















    













        

    







    





        

    































































    















    











    





        





            

        

    



























    





        

    







    

        

    









    

        

        

        

    









    

        

              

        





    









    

        

    









    

        

    













    



















typedef int                           errno_t;

typedef unsigned short                wint_t;

typedef unsigned short                wctype_t;

typedef long                          __time32_t;

typedef __int64                       __time64_t;



typedef struct __crt_locale_data_public

{

      unsigned short const* _locale_pctype;

      int _locale_mb_cur_max;

               unsigned int _locale_lc_codepage;

} __crt_locale_data_public;



typedef struct __crt_locale_pointers

{

    struct __crt_locale_data*    locinfo;

    struct __crt_multibyte_data* mbcinfo;

} __crt_locale_pointers;



typedef __crt_locale_pointers* _locale_t; 



typedef struct _Mbstatet

{ 

    unsigned long _Wchar;

    unsigned short _Byte, _State;

} _Mbstatet;



typedef _Mbstatet mbstate_t;



















    



        typedef __time64_t time_t;

    









    







    typedef size_t rsize_t;























    





























        

        

        

        

        

        

        

        

        

        

        

        



    















































































































    















































































































































        

        

        

        



        



        



        



        



        



        



        



        



        



        



        



        



        



        



        



        



        



        



        



        



        



        



        



        



        





        



        



        



        



        



        



        



        



        



        



        



        



        



        



        



        



    









 





 



















     void  _wassert(

         wchar_t const* _Message,

         wchar_t const* _File,

         unsigned       _Line

        );



    











 











































































 











    







    









































































  

   unsigned __int64*  __local_stdio_printf_options(void)

{

    static unsigned __int64 _OptionsStorage;

    return &_OptionsStorage;

}







  

   unsigned __int64*  __local_stdio_scanf_options(void)

{

    static unsigned __int64 _OptionsStorage;

    return &_OptionsStorage;

}







































 









 

















    

    typedef struct _iobuf

    {

        void* _Placeholder;

    } FILE;





 FILE*  __acrt_iob_func(unsigned);





























 

 wint_t  fgetwc(

     FILE* _Stream

    );



 

 wint_t  _fgetwchar(void);



 

 wint_t  fputwc(

     wchar_t _Character,

     FILE*   _Stream);



 

 wint_t  _fputwchar(

     wchar_t _Character

    );



 

 wint_t  getwc(

     FILE* _Stream

    );



 

 wint_t  getwchar(void);





 

 

 wchar_t*  fgetws(

      wchar_t* _Buffer,

     int      _BufferCount,

     FILE*    _Stream

    );



 

 int  fputws(

     wchar_t const* _Buffer,

     FILE*          _Stream

    );



 

 

 wchar_t*  _getws_s(

      wchar_t* _Buffer,

     size_t   _BufferCount

    );



 



 

 wint_t  putwc(

     wchar_t _Character,

     FILE*   _Stream

    );



 

 wint_t  putwchar(

     wchar_t _Character

    );



 

 int  _putws(

     wchar_t const* _Buffer

    );



 

 wint_t  ungetwc(

     wint_t _Character,

     FILE*  _Stream

    );



 

 FILE *  _wfdopen(

     int            _FileHandle,

     wchar_t const* _Mode

    );



  

 FILE*  _wfopen(

     wchar_t const* _FileName,

     wchar_t const* _Mode

    );



 

 errno_t  _wfopen_s(

     FILE**         _Stream,

     wchar_t const* _FileName,

     wchar_t const* _Mode

    );



 

 

 FILE*  _wfreopen(

     wchar_t const* _FileName,

     wchar_t const* _Mode,

     FILE*          _OldStream

    );



 

 errno_t  _wfreopen_s(

     FILE**         _Stream,

     wchar_t const* _FileName,

     wchar_t const* _Mode,

     FILE*          _OldStream

    );



 

 FILE*  _wfsopen(

     wchar_t const* _FileName,

     wchar_t const* _Mode,

     int            _ShFlag

    );



 void  _wperror(

     wchar_t const* _ErrorMessage

    );







     

     FILE*  _wpopen(

         wchar_t const* _Command,

         wchar_t const* _Mode

        );







 int  _wremove(

     wchar_t const* _FileName

    );









 

  wchar_t*  _wtempnam(

     wchar_t const* _Directory,

     wchar_t const* _FilePrefix

    );







 

 

 errno_t  _wtmpnam_s(

      wchar_t* _Buffer,

     size_t   _BufferCount

    );



 





 

 wchar_t * _wtmpnam ( 

 wchar_t * _Buffer 

 ) ; 

















 

 wint_t  _fgetwc_nolock(

     FILE* _Stream

    );



 

 wint_t  _fputwc_nolock(

     wchar_t _Character, 

     FILE*   _Stream

    );



 

 wint_t  _getwc_nolock(

     FILE* _Stream

    );



 

 wint_t  _putwc_nolock(

     wchar_t _Character,

     FILE*   _Stream

    );



 

 wint_t  _ungetwc_nolock(

     wint_t _Character,

     FILE*  _Stream

    );









































 

 int  __stdio_common_vfwprintf(

     unsigned __int64 _Options,

     FILE*            _Stream,

       wchar_t const*   _Format,

     _locale_t        _Locale,

                                            va_list          _ArgList

    );



 

 int  __stdio_common_vfwprintf_s(

     unsigned __int64 _Options,

     FILE*            _Stream,

       wchar_t const*   _Format,

     _locale_t        _Locale,

                                            va_list          _ArgList

    );



 

 int  __stdio_common_vfwprintf_p(

     unsigned __int64 _Options,

     FILE*            _Stream,

       wchar_t const*   _Format,

     _locale_t        _Locale,

                                            va_list          _ArgList

    );



 

 int  _vfwprintf_l(

     FILE*          const _Stream,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

                                            va_list              _ArgList

    )





{

    return __stdio_common_vfwprintf(( * __local_stdio_printf_options ( ) ) , _Stream, _Format, _Locale, _ArgList);

}





 

 int  vfwprintf(

     FILE*          const _Stream,

      wchar_t const* const _Format,

                                  va_list              _ArgList

    )





{

    return _vfwprintf_l(_Stream, _Format, ( ( void * ) 0 ) , _ArgList);

}





 

 int  _vfwprintf_s_l(

     FILE*          const _Stream,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

                                            va_list              _ArgList

    )





{

    return __stdio_common_vfwprintf_s(( * __local_stdio_printf_options ( ) ) , _Stream, _Format, _Locale, _ArgList);

}









     

     int  vfwprintf_s(

         FILE*          const _Stream,

          wchar_t const* const _Format,

                                      va_list              _ArgList

        )





    {

        return _vfwprintf_s_l(_Stream, _Format, ( ( void * ) 0 ) , _ArgList);

    }









 

 int  _vfwprintf_p_l(

     FILE*          const _Stream,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

                                            va_list              _ArgList

    )





{

    return __stdio_common_vfwprintf_p(( * __local_stdio_printf_options ( ) ) , _Stream, _Format, _Locale, _ArgList);

}





 

 int  _vfwprintf_p(

     FILE*          const _Stream,

      wchar_t const* const _Format,

                                  va_list              _ArgList

    )





{

    return _vfwprintf_p_l(_Stream, _Format, ( ( void * ) 0 ) , _ArgList);

}





 

 int  _vwprintf_l(

       wchar_t const* const _Format,

     _locale_t      const _Locale,

                                            va_list              _ArgList

    )





{

    return _vfwprintf_l(( __acrt_iob_func ( 1 ) ) , _Format, _Locale, _ArgList);

}





 

 int  vwprintf(

      wchar_t const* const _Format,

                                  va_list              _ArgList

    )





{

    return _vfwprintf_l(( __acrt_iob_func ( 1 ) ) , _Format, ( ( void * ) 0 ) , _ArgList);

}





 

 int  _vwprintf_s_l(

       wchar_t const* const _Format,

     _locale_t      const _Locale,

                                            va_list              _ArgList

    )





{

    return _vfwprintf_s_l(( __acrt_iob_func ( 1 ) ) , _Format, _Locale, _ArgList);

}









     

     int  vwprintf_s(

          wchar_t const* const _Format,

                                      va_list              _ArgList

        )





    {

        return _vfwprintf_s_l(( __acrt_iob_func ( 1 ) ) , _Format, ( ( void * ) 0 ) , _ArgList);

    }









 

 int  _vwprintf_p_l(

       wchar_t const* const _Format,

     _locale_t      const _Locale,

                                            va_list              _ArgList

    )





{

    return _vfwprintf_p_l(( __acrt_iob_func ( 1 ) ) , _Format, _Locale, _ArgList);

}





 

 int  _vwprintf_p(

      wchar_t const* const _Format,

                                  va_list              _ArgList

    )





{

    return _vfwprintf_p_l(( __acrt_iob_func ( 1 ) ) , _Format, ( ( void * ) 0 ) , _ArgList);

}





 

 int  _fwprintf_l(

     FILE*          const _Stream,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  fwprintf(

     FILE*          const _Stream,

      wchar_t const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfwprintf_l(_Stream, _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  _fwprintf_s_l(

     FILE*          const _Stream,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}









     

     int  fwprintf_s(

         FILE*          const _Stream,

          wchar_t const* const _Format,

        ...)





    {

        int _Result;

        va_list _ArgList;

        ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

        _Result = _vfwprintf_s_l(_Stream, _Format, ( ( void * ) 0 ) , _ArgList);

        ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

        return _Result;

    }









 

 int  _fwprintf_p_l(

     FILE*          const _Stream,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  _fwprintf_p(

     FILE*          const _Stream,

      wchar_t const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfwprintf_p_l(_Stream, _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  _wprintf_l(

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfwprintf_l(( __acrt_iob_func ( 1 ) ) , _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  wprintf(

      wchar_t const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfwprintf_l(( __acrt_iob_func ( 1 ) ) , _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  _wprintf_s_l(

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfwprintf_s_l(( __acrt_iob_func ( 1 ) ) , _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}









     

     int  wprintf_s(

          wchar_t const* const _Format,

        ...)





    {

        int _Result;

        va_list _ArgList;

        ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

        _Result = _vfwprintf_s_l(( __acrt_iob_func ( 1 ) ) , _Format, ( ( void * ) 0 ) , _ArgList);

        ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

        return _Result;

    }









 

 int  _wprintf_p_l(

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfwprintf_p_l(( __acrt_iob_func ( 1 ) ) , _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  _wprintf_p(

      wchar_t const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfwprintf_p_l(( __acrt_iob_func ( 1 ) ) , _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}

















 

 int  __stdio_common_vfwscanf(

     unsigned __int64 _Options,

     FILE*            _Stream,

       wchar_t const*   _Format,

     _locale_t        _Locale,

                                           va_list          _ArgList

    );



 

 int  _vfwscanf_l(

     FILE*                                const _Stream,

      wchar_t const* const _Format,

     _locale_t      const _Locale,

                                  va_list              _ArgList

    )





{

    return __stdio_common_vfwscanf(

        ( * __local_stdio_scanf_options ( ) ) ,

        _Stream, _Format, _Locale, _ArgList);

}





 

 int  vfwscanf(

     FILE*                                const _Stream,

      wchar_t const* const _Format,

                                  va_list              _ArgList

    )





{

    return _vfwscanf_l(_Stream, _Format, ( ( void * ) 0 ) , _ArgList);

}





 

 int  _vfwscanf_s_l(

     FILE*          const _Stream,

      wchar_t const* const _Format,

     _locale_t      const _Locale,

                                  va_list              _ArgList

    )





{

    return __stdio_common_vfwscanf(

        ( * __local_stdio_scanf_options ( ) ) | ( 1ULL << 0 ) ,

        _Stream, _Format, _Locale, _ArgList);

}









     

     int  vfwscanf_s(

         FILE*          const _Stream,

          wchar_t const* const _Format,

                                      va_list              _ArgList

        )





    {

        return _vfwscanf_s_l(_Stream, _Format, ( ( void * ) 0 ) , _ArgList);

    }









 int  _vwscanf_l(

      wchar_t const* const _Format,

     _locale_t      const _Locale,

                                  va_list              _ArgList

    )





{

    return _vfwscanf_l(( __acrt_iob_func ( 0 ) ) , _Format, _Locale, _ArgList);

}





 

 int  vwscanf(

      wchar_t const* const _Format,

                                  va_list              _ArgList

    )





{

    return _vfwscanf_l(( __acrt_iob_func ( 0 ) ) , _Format, ( ( void * ) 0 ) , _ArgList);

}





 

 int  _vwscanf_s_l(

      wchar_t const* const _Format,

     _locale_t      const _Locale,

                                  va_list              _ArgList

    )





{

    return _vfwscanf_s_l(( __acrt_iob_func ( 0 ) ) , _Format, _Locale, _ArgList);

}









     

     int  vwscanf_s(

          wchar_t const* const _Format,

                                      va_list              _ArgList

        )





    {

        return _vfwscanf_s_l(( __acrt_iob_func ( 0 ) ) , _Format, ( ( void * ) 0 ) , _ArgList);

    }









  

 int  _fwscanf_l(

     FILE*          const _Stream,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





  

 int  fwscanf(

     FILE*          const _Stream,

      wchar_t const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfwscanf_l(_Stream, _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  _fwscanf_s_l(

     FILE*          const _Stream,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}









     

     int  fwscanf_s(

         FILE*          const _Stream,

          wchar_t const* const _Format,

        ...)





    {

        int _Result;

        va_list _ArgList;

        ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

        _Result = _vfwscanf_s_l(_Stream, _Format, ( ( void * ) 0 ) , _ArgList);

        ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

        return _Result;

    }









  

 int  _wscanf_l(

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfwscanf_l(( __acrt_iob_func ( 0 ) ) , _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





  

 int  wscanf(

      wchar_t const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfwscanf_l(( __acrt_iob_func ( 0 ) ) , _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  _wscanf_s_l(

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfwscanf_s_l(( __acrt_iob_func ( 0 ) ) , _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}









     

     int  wscanf_s(

          wchar_t const* const _Format,

        ...)





    {

        int _Result;

        va_list _ArgList;

        ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

        _Result = _vfwscanf_s_l(( __acrt_iob_func ( 0 ) ) , _Format, ( ( void * ) 0 ) , _ArgList);

        ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

        return _Result;

    }

























    









 

 

 int  __stdio_common_vswprintf(

     unsigned __int64 _Options,

                 wchar_t*         _Buffer,

     size_t           _BufferCount,

       wchar_t const*   _Format,

     _locale_t        _Locale,

                                            va_list          _ArgList

    );



 

 

 int  __stdio_common_vswprintf_s(

     unsigned __int64 _Options,

                 wchar_t*         _Buffer,

     size_t           _BufferCount,

       wchar_t const*   _Format,

     _locale_t        _Locale,

                                            va_list          _ArgList

    );



 

 

 int  __stdio_common_vsnwprintf_s(

     unsigned __int64 _Options,

                 wchar_t*         _Buffer,

     size_t           _BufferCount,

     size_t           _MaxCount,

       wchar_t const*   _Format,

     _locale_t        _Locale,

                                            va_list          _ArgList

    );



 

 

 int  __stdio_common_vswprintf_p(

     unsigned __int64 _Options,

                 wchar_t*         _Buffer,

     size_t           _BufferCount,

       wchar_t const*   _Format,

     _locale_t        _Locale,

                                            va_list          _ArgList

    );



 

  

 int  _vsnwprintf_l(

       wchar_t*       const _Buffer,

     size_t         const _BufferCount,

           wchar_t const* const _Format,

     _locale_t      const _Locale,

                                                va_list              _ArgList

    )





{

    int const _Result = __stdio_common_vswprintf(

        ( * __local_stdio_printf_options ( ) ) | ( 1ULL << 0 ) ,

        _Buffer, _BufferCount, _Format, _Locale, _ArgList);



    return _Result < 0 ? -1 : _Result;

}











 

 

 int  _vsnwprintf_s_l(

                 wchar_t*       const _Buffer,

     size_t         const _BufferCount,

     size_t         const _MaxCount,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

                                            va_list              _ArgList

    )





{

    int const _Result = __stdio_common_vsnwprintf_s(

        ( * __local_stdio_printf_options ( ) ) ,

        _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);



    return _Result < 0 ? -1 : _Result;

}





 

 

 int  _vsnwprintf_s(

       wchar_t*       const _Buffer,

     size_t         const _BufferCount,

     size_t         const _MaxCount,

      wchar_t const* const _Format,

                                  va_list              _ArgList

    )





{

    return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ( ( void * ) 0 ) , _ArgList);

}







 

 int _snwprintf ( 

 wchar_t * _Buffer , 

 size_t _BufferCount , 

 wchar_t const * _Format 

 , ... ) ; 

 

 int _vsnwprintf ( 

 wchar_t * _Buffer , 

 size_t _BufferCount , 

 wchar_t const * _Format 

 , va_list _Args ) ; 







 

  

 int  _vsnwprintf(

       wchar_t*       _Buffer,

     size_t         _BufferCount,

      wchar_t const* _Format,

                                             va_list        _ArgList

    )





{

    

    

    return _vsnwprintf_l(_Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);

    

}





 



 

 

 int  _vswprintf_c_l(

                 wchar_t*       const _Buffer,

     size_t         const _BufferCount,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

                                            va_list              _ArgList

    )





{

    int const _Result = __stdio_common_vswprintf(

        ( * __local_stdio_printf_options ( ) ) ,

        _Buffer, _BufferCount, _Format, _Locale, _ArgList);



    return _Result < 0 ? -1 : _Result;

}





 

 

 int  _vswprintf_c(

       wchar_t*       const _Buffer,

     size_t         const _BufferCount,

      wchar_t const* const _Format,

                                  va_list              _ArgList

    )





{

    return _vswprintf_c_l(_Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);

}





 

 

 int  _vswprintf_l(

      wchar_t*       const _Buffer,

     size_t         const _BufferCount,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

                                            va_list              _ArgList

    )





{

    

    

    return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

    

}





 

 

 int  __vswprintf_l(

      wchar_t*       const _Buffer,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

                                            va_list              _ArgList

    )





{

    return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

}





 

 

 int  _vswprintf(

      wchar_t*       const _Buffer,

      wchar_t const* const _Format,

                                  va_list              _ArgList

    )





{

    return _vswprintf_l(_Buffer, (size_t)-1, _Format, ( ( void * ) 0 ) , _ArgList);

}





 

 

 int  vswprintf(

      wchar_t*       const _Buffer,

     size_t         const _BufferCount,

       wchar_t const* const _Format,

                                            va_list              _ArgList

    )





{

    return _vswprintf_c_l(_Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);

}





 

 

 int  _vswprintf_s_l(

                 wchar_t*       const _Buffer,

     size_t         const _BufferCount,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

                                            va_list              _ArgList

    )





{

    int const _Result = __stdio_common_vswprintf_s(

        ( * __local_stdio_printf_options ( ) ) ,

        _Buffer, _BufferCount, _Format, _Locale, _ArgList);



    return _Result < 0 ? -1 : _Result;

}









     

     int  vswprintf_s(

           wchar_t*       const _Buffer,

         size_t         const _BufferCount,

          wchar_t const* const _Format,

                                      va_list              _ArgList

        )





    {

        return _vswprintf_s_l(_Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);

    }









 



 

 

 int  _vswprintf_p_l(

                 wchar_t*       const _Buffer,

     size_t         const _BufferCount,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

                                            va_list              _ArgList

    )





{

    int const _Result = __stdio_common_vswprintf_p(

        ( * __local_stdio_printf_options ( ) ) ,

        _Buffer, _BufferCount, _Format, _Locale, _ArgList);



    return _Result < 0 ? -1 : _Result;

}





 

 

 int  _vswprintf_p(

       wchar_t*       const _Buffer,

     size_t         const _BufferCount,

      wchar_t const* const _Format,

                                  va_list              _ArgList

    )





{

    return _vswprintf_p_l(_Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);

}





 

 

 int  _vscwprintf_l(

       wchar_t const* const _Format,

     _locale_t      const _Locale,

                                            va_list              _ArgList

    )





{

    int const _Result = __stdio_common_vswprintf(

        ( * __local_stdio_printf_options ( ) ) | ( 1ULL << 1 ) ,

        ( ( void * ) 0 ) , 0, _Format, _Locale, _ArgList);



    return _Result < 0 ? -1 : _Result;

}





 

 

 int  _vscwprintf(

      wchar_t const* const _Format,

                                  va_list              _ArgList

    )





{

    return _vscwprintf_l(_Format, ( ( void * ) 0 ) , _ArgList);

}





 

 

 int  _vscwprintf_p_l(

       wchar_t const* const _Format,

     _locale_t      const _Locale,

                                            va_list              _ArgList

    )





{

    int const _Result = __stdio_common_vswprintf_p(

        ( * __local_stdio_printf_options ( ) ) | ( 1ULL << 1 ) ,

        ( ( void * ) 0 ) , 0, _Format, _Locale, _ArgList);



    return _Result < 0 ? -1 : _Result;

}





 

 

 int  _vscwprintf_p(

      wchar_t const* const _Format, 

                                  va_list              _ArgList

    )





{

    return _vscwprintf_p_l(_Format, ( ( void * ) 0 ) , _ArgList);

}





 

 

 int  __swprintf_l(

      wchar_t*       const _Buffer,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 

 int  _swprintf_l(

      wchar_t*       const _Buffer,

     size_t         const _BufferCount,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 

 int  _swprintf(

      wchar_t*       const _Buffer,

      wchar_t const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = __vswprintf_l(_Buffer, _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 

 int  swprintf(

      wchar_t*       const _Buffer,

     size_t         const _BufferCount,

      wchar_t const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}

















 

 int __swprintf_l ( 

 wchar_t * _Buffer , 

 wchar_t const * _Format , 

 _locale_t _Locale 

 , ... ) ; 

 

 int __vswprintf_l ( 

 wchar_t * _Buffer , 

 wchar_t const * _Format , 

 _locale_t _Locale 

 , va_list _Args ) ; 





 

 int _swprintf ( 

 wchar_t * _Buffer , 

 wchar_t const * _Format 

 , ... ) ; 

 

 int _vswprintf ( 

 wchar_t * _Buffer , 

 wchar_t const * _Format 

 , va_list _Args ) ; 







 

 

 int  _swprintf_s_l(

                 wchar_t*       const _Buffer,

     size_t         const _BufferCount,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}









     

     int  swprintf_s(

           wchar_t*       const _Buffer,

         size_t         const _BufferCount,

          wchar_t const* const _Format,

        ...)





    {

        int _Result;

        va_list _ArgList;

        ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);

        ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

        return _Result;

    }









 



 

 

 int  _swprintf_p_l(

                 wchar_t*       const _Buffer,

     size_t         const _BufferCount,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 

 int  _swprintf_p(

       wchar_t*       const _Buffer,

     size_t         const _BufferCount,

      wchar_t const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 

 int  _swprintf_c_l(

                 wchar_t*       const _Buffer,

     size_t         const _BufferCount,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 

 int  _swprintf_c(

       wchar_t*       const _Buffer,

     size_t         const _BufferCount,

      wchar_t const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

  

 int  _snwprintf_l(

       wchar_t*       const _Buffer,

     size_t         const _BufferCount,

        wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;



    

    

    _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

    



    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 

 int  _snwprintf(

       wchar_t*       _Buffer,

     size_t         _BufferCount,

      wchar_t const* _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;



    

    

    _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);

    



    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 

 int  _snwprintf_s_l(

                 wchar_t*       const _Buffer,

     size_t         const _BufferCount,

     size_t         const _MaxCount,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 

 int  _snwprintf_s(

       wchar_t*       const _Buffer,

     size_t         const _BufferCount,

     size_t         const _MaxCount,

      wchar_t const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 



 

 int  _scwprintf_l(

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vscwprintf_l(_Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 

 int  _scwprintf(

      wchar_t const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vscwprintf_l(_Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 

 int  _scwprintf_p_l(

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 

 int  _scwprintf_p(

      wchar_t const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vscwprintf_p_l(_Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}









    

    



    





    































 

 int  __stdio_common_vswscanf(

     unsigned __int64 _Options,

       wchar_t const*   _Buffer,

     size_t           _BufferCount,

       wchar_t const*   _Format,

     _locale_t        _Locale,

                                           va_list          _ArgList

    );



 

 

 int  _vswscanf_l(

     wchar_t const* const _Buffer,

      wchar_t const* const _Format,

     _locale_t      const _Locale,

                                  va_list              _ArgList

    )





{

    return __stdio_common_vswscanf(

        ( * __local_stdio_scanf_options ( ) ) ,

        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);

}





 

 

 int  vswscanf(

     wchar_t const* _Buffer,

      wchar_t const* _Format,

                                  va_list        _ArgList

    )





{

    return _vswscanf_l(_Buffer, _Format, ( ( void * ) 0 ) , _ArgList);

}





 

 

 int  _vswscanf_s_l(

     wchar_t const* const _Buffer,

      wchar_t const* const _Format,

     _locale_t      const _Locale,

                                  va_list              _ArgList

    )





{

    return __stdio_common_vswscanf(

        ( * __local_stdio_scanf_options ( ) ) | ( 1ULL << 0 ) ,

        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);

}









     

     

     int  vswscanf_s(

         wchar_t const* const _Buffer,

          wchar_t const* const _Format,

                                      va_list              _ArgList

        )





    {

        return _vswscanf_s_l(_Buffer, _Format, ( ( void * ) 0 ) , _ArgList);

    }









 



 

  

 int  _vsnwscanf_l(

       wchar_t const* const _Buffer,

     size_t         const _BufferCount,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

                                           va_list              _ArgList

    )





{

    return __stdio_common_vswscanf(

        ( * __local_stdio_scanf_options ( ) ) ,

        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

}





 

 

 int  _vsnwscanf_s_l(

       wchar_t const* const _Buffer,

     size_t         const _BufferCount,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

                                             va_list              _ArgList

    )





{

    return __stdio_common_vswscanf(

        ( * __local_stdio_scanf_options ( ) ) | ( 1ULL << 0 ) ,

        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

}





 

  

 int  _swscanf_l(

     wchar_t const* const _Buffer,

       wchar_t const* const _Format,

     _locale_t            _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

  

 int  swscanf(

     wchar_t const* const _Buffer,

      wchar_t const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vswscanf_l(_Buffer, _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 

 int  _swscanf_s_l(

     wchar_t const* const _Buffer,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}









     

     

     int  swscanf_s(

         wchar_t const* const _Buffer,

          wchar_t const* const _Format,

        ...)





    {

        int _Result;

        va_list _ArgList;

        ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

        _Result = _vswscanf_s_l(_Buffer, _Format, ( ( void * ) 0 ) , _ArgList);  

        ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

        return _Result;

    }









 

  

 int  _snwscanf_l(

       wchar_t const* const _Buffer,

     size_t         const _BufferCount,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;



    

    

    _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

    



    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

  

 int  _snwscanf(

       wchar_t const* const _Buffer,

     size_t         const _BufferCount,

      wchar_t const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;



    

    

    _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);

    



    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 

 int  _snwscanf_s_l(

       wchar_t const* const _Buffer,

     size_t         const _BufferCount,

       wchar_t const* const _Format,

     _locale_t      const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 

 int  _snwscanf_s(

       wchar_t const* const _Buffer,

     size_t         const _BufferCount,

      wchar_t const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}















 





 



















































    

































    

    







typedef __int64 fpos_t;







 

 errno_t  _get_stream_buffer_pointers(

     FILE*   _Stream,

     char*** _Base,

     char*** _Pointer,

     int**   _Count

    );



















     

     errno_t  clearerr_s(

         FILE* _Stream

        );



     

     errno_t  fopen_s(

         FILE**      _Stream,

         char const* _FileName,

         char const* _Mode

        );

    

     

     

     size_t  fread_s(

            void*  _Buffer,

                       size_t _BufferSize,

         size_t _ElementSize,

         size_t _ElementCount,

         FILE*  _Stream

        );

    

     

     errno_t  freopen_s(

         FILE**      _Stream,

         char const* _FileName,

         char const* _Mode,

         FILE*       _OldStream

        );



     

     char*  gets_s(

          char*   _Buffer,

         rsize_t _Size

        );



     

     errno_t  tmpfile_s(

          FILE** _Stream

        );



     

     

     errno_t  tmpnam_s(

          char*   _Buffer,

         rsize_t _Size

        );







 void  clearerr(

     FILE* _Stream

    );



 

 

 int  fclose(

     FILE* _Stream

    );



 

 int  _fcloseall(void);



 

 FILE*  _fdopen(

     int         _FileHandle,

     char const* _Mode

    );



 

 int  feof(

     FILE* _Stream

    );



 

 int  ferror(

     FILE* _Stream

    );



 

 int  fflush(

     FILE* _Stream

    );



 

 

 int  fgetc(

     FILE* _Stream

    );



 

 int  _fgetchar(void);



 

 

 int  fgetpos(

     FILE*   _Stream,

     fpos_t* _Position

    );



 

 

 char*  fgets(

      char* _Buffer,

     int   _MaxCount,

     FILE* _Stream

    );



 

 int  _fileno(

     FILE* _Stream

    );



 

 int  _flushall(void);



  

 FILE*  fopen(

     char const* _FileName,

     char const* _Mode

    );





 

 

 int  fputc(

     int   _Character,

     FILE* _Stream

    );



 

 int  _fputchar(

     int _Character

    );



 

 

 int  fputs(

     char const* _Buffer,

     FILE*       _Stream

    );



 

 size_t  fread(

      void*  _Buffer,

     size_t _ElementSize,

     size_t _ElementCount,

     FILE*  _Stream

    );



 

  

 FILE*  freopen(

     char const* _FileName,

     char const* _Mode,

     FILE*       _Stream

    );



 

 FILE*  _fsopen(

     char const* _FileName,

     char const* _Mode,

     int         _ShFlag

    );



 

 

 int  fsetpos(

     FILE*         _Stream,

     fpos_t const* _Position

    );



 

 

 int  fseek(

     FILE* _Stream,

     long  _Offset,

     int   _Origin

    );



 

 

 int  _fseeki64(

     FILE*   _Stream,

     __int64 _Offset,

     int     _Origin

    );



 

 

 long  ftell(

     FILE* _Stream

    );



 

 

 __int64  _ftelli64(

     FILE* _Stream

    );



 

 size_t  fwrite(

      void const* _Buffer,

     size_t      _ElementSize,

     size_t      _ElementCount,

     FILE*       _Stream

    );



 

 

 int  getc(

     FILE* _Stream

    );



 

 int  getchar(void);



 

 int  _getmaxstdio(void);



 



 

 int  _getw(

     FILE* _Stream

    );



 void  perror(

     char const* _ErrorMessage

    );







     

     

     int  _pclose(

         FILE* _Stream

        );



     

     FILE*  _popen(

         char const* _Command,

         char const* _Mode

        );







 

 

 int  putc(

     int   _Character,

     FILE* _Stream

    );



 

 int  putchar(

     int _Character

    );



 

 int  puts(

     char const* _Buffer

    );



 

 

 int  _putw(

     int   _Word, 

     FILE* _Stream

    );







 int  remove(

     char const* _FileName

    );



 

 int  rename(

     char const* _OldFileName,

     char const* _NewFileName

    );



 int  _unlink(

     char const* _FileName

    );













 void  rewind(

     FILE* _Stream

    );



 

 int  _rmtmp(void);



 

 void  setbuf(

     FILE* _Stream,

        char* _Buffer

    );



 

 int  _setmaxstdio(

     int _Maximum

    );



 

 

 int  setvbuf(

     FILE*  _Stream,

        char*  _Buffer,

     int    _Mode,

     size_t _Size

    );









 

  char*  _tempnam(

     char const* _DirectoryName,

     char const* _FilePrefix

    );









  

 FILE*  tmpfile(void);



 





 

 char * tmpnam ( 

 char * _Buffer 

 ) ; 



 

 

 int  ungetc(

     int   _Character,

     FILE* _Stream

    );

















 void  _lock_file(

     FILE* _Stream

    );



 void  _unlock_file(

     FILE* _Stream

    );



 

 

 int  _fclose_nolock(

     FILE* _Stream

    );



 

 

 int  _fflush_nolock(

     FILE* _Stream

    );



 

 

 int  _fgetc_nolock(

     FILE* _Stream

    );



 

 

 int  _fputc_nolock(

     int   _Character,

     FILE* _Stream

    );



 

 size_t  _fread_nolock(

      void*  _Buffer,

     size_t _ElementSize,

     size_t _ElementCount,

     FILE*  _Stream

    );



 

 

 size_t  _fread_nolock_s(

      void*  _Buffer,

               size_t _BufferSize,

     size_t _ElementSize,

     size_t _ElementCount,

     FILE*  _Stream

    );



 

 int  _fseek_nolock(

     FILE* _Stream,

     long  _Offset,

     int   _Origin

    );



 

 int  _fseeki64_nolock(

     FILE*   _Stream,

     __int64 _Offset,

     int     _Origin

    );



 

 long  _ftell_nolock(

     FILE* _Stream

    );



 

 __int64  _ftelli64_nolock(

     FILE* _Stream

    );



 

 size_t  _fwrite_nolock(

      void const* _Buffer,

     size_t      _ElementSize,

     size_t      _ElementCount,

     FILE*       _Stream

    );



 

 int  _getc_nolock(

     FILE* _Stream

    );



 

 int  _putc_nolock(

     int   _Character,

     FILE* _Stream

    );



 

 int  _ungetc_nolock(

     int   _Character,

     FILE* _Stream

    );





















































 int*  __p__commode(void);







    



























 int  __stdio_common_vfprintf(

     unsigned __int64 _Options,

     FILE*            _Stream,

       char const*      _Format,

     _locale_t        _Locale,

                                            va_list          _ArgList

    );



 int  __stdio_common_vfprintf_s(

     unsigned __int64 _Options,

     FILE*            _Stream,

       char const*      _Format,

     _locale_t        _Locale,

                                            va_list          _ArgList

    );



 

 int  __stdio_common_vfprintf_p(

     unsigned __int64 _Options,

     FILE*            _Stream,

       char const*      _Format,

     _locale_t        _Locale,

                                            va_list          _ArgList

    );



 

 int  _vfprintf_l(

     FILE*       const _Stream,

     char const* const _Format,

     _locale_t   const _Locale,

             va_list           _ArgList

    )





{

    return __stdio_common_vfprintf(( * __local_stdio_printf_options ( ) ) , _Stream, _Format, _Locale, _ArgList);

}





 

 int  vfprintf(

     FILE*       const _Stream,

      char const* const _Format,

                                  va_list           _ArgList

    )





{

    return _vfprintf_l(_Stream, _Format, ( ( void * ) 0 ) , _ArgList);

}





 

 int  _vfprintf_s_l(

     FILE*       const _Stream,

     char const* const _Format,

     _locale_t   const _Locale,

             va_list           _ArgList

    )





{

    return __stdio_common_vfprintf_s(( * __local_stdio_printf_options ( ) ) , _Stream, _Format, _Locale, _ArgList);

}









     

     int  vfprintf_s(

         FILE*       const _Stream,

          char const* const _Format,

                                      va_list           _ArgList

        )





    {

        return _vfprintf_s_l(_Stream, _Format, ( ( void * ) 0 ) , _ArgList);

    }









 

 int  _vfprintf_p_l(

     FILE*       const _Stream,

     char const* const _Format,

     _locale_t   const _Locale,

             va_list           _ArgList

    )





{

    return __stdio_common_vfprintf_p(( * __local_stdio_printf_options ( ) ) , _Stream, _Format, _Locale, _ArgList);

}





 

 int  _vfprintf_p(

     FILE*       const _Stream,

      char const* const _Format,

                                  va_list           _ArgList

    )





{

    return _vfprintf_p_l(_Stream, _Format, ( ( void * ) 0 ) , _ArgList);

}





 

 int  _vprintf_l(

       char const* const _Format,

     _locale_t   const _Locale,

                                            va_list           _ArgList

    )





{

    return _vfprintf_l(( __acrt_iob_func ( 1 ) ) , _Format, _Locale, _ArgList);

}





 

 int  vprintf(

      char const* const _Format,

                                  va_list           _ArgList

    )





{

    return _vfprintf_l(( __acrt_iob_func ( 1 ) ) , _Format, ( ( void * ) 0 ) , _ArgList);

}





 

 int  _vprintf_s_l(

       char const* const _Format,

     _locale_t   const _Locale,

                                            va_list           _ArgList

    )





{

    return _vfprintf_s_l(( __acrt_iob_func ( 1 ) ) , _Format, _Locale, _ArgList);

}









     

     int  vprintf_s(

          char const* const _Format,

                                      va_list           _ArgList

        )





    {

        return _vfprintf_s_l(( __acrt_iob_func ( 1 ) ) , _Format, ( ( void * ) 0 ) , _ArgList);

    }









 

 int  _vprintf_p_l(

       char const* const _Format,

     _locale_t   const _Locale,

                                            va_list           _ArgList

    )





{

    return _vfprintf_p_l(( __acrt_iob_func ( 1 ) ) , _Format, _Locale, _ArgList);

}





 

 int  _vprintf_p(

      char const* const _Format,

                                  va_list           _ArgList

    )





{

    return _vfprintf_p_l(( __acrt_iob_func ( 1 ) ) , _Format, ( ( void * ) 0 ) , _ArgList);

}





 

 int  _fprintf_l(

     FILE*       const _Stream,

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  fprintf(

     FILE*       const _Stream,

      char const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfprintf_l(_Stream, _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 int  _set_printf_count_output(

     int _Value

    );



 int  _get_printf_count_output(void);



 

 int  _fprintf_s_l(

     FILE*       const _Stream,

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}









     

     int  fprintf_s(

         FILE*       const _Stream,

          char const* const _Format,

        ...)





    {

        int _Result;

        va_list _ArgList;

        ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

        _Result = _vfprintf_s_l(_Stream, _Format, ( ( void * ) 0 ) , _ArgList);

        ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

        return _Result;

    }









 

 int  _fprintf_p_l(

     FILE*       const _Stream,

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  _fprintf_p(

     FILE*       const _Stream,

      char const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfprintf_p_l(_Stream, _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  _printf_l(

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfprintf_l(( __acrt_iob_func ( 1 ) ) , _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  printf(

      char const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfprintf_l(( __acrt_iob_func ( 1 ) ) , _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  _printf_s_l(

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfprintf_s_l(( __acrt_iob_func ( 1 ) ) , _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}









     

     int  printf_s(

          char const* const _Format,

        ...)





    {

        int _Result;

        va_list _ArgList;

        ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

        _Result = _vfprintf_s_l(( __acrt_iob_func ( 1 ) ) , _Format, ( ( void * ) 0 ) , _ArgList);

        ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

        return _Result;

    }









 

 int  _printf_p_l(

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfprintf_p_l(( __acrt_iob_func ( 1 ) ) , _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  _printf_p(

      char const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfprintf_p_l(( __acrt_iob_func ( 1 ) ) , _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}

















 int  __stdio_common_vfscanf(

     unsigned __int64 _Options,

     FILE*            _Stream,

       char const*      _Format,

     _locale_t        _Locale,

                                           va_list          _Arglist

    );



 

 int  _vfscanf_l(

     FILE*       const _Stream,

      char const* const _Format,

     _locale_t   const _Locale,

                                  va_list           _ArgList

    )





{

    return __stdio_common_vfscanf(

        ( * __local_stdio_scanf_options ( ) ) ,

        _Stream, _Format, _Locale, _ArgList);

}





 

 int  vfscanf(

     FILE*       const _Stream,

      char const* const _Format,

                                  va_list           _ArgList

    )





{

    return _vfscanf_l(_Stream, _Format, ( ( void * ) 0 ) , _ArgList);

}





 

 int  _vfscanf_s_l(

     FILE*       const _Stream,

      char const* const _Format,

     _locale_t   const _Locale,

                                  va_list           _ArgList

    )





{

    return __stdio_common_vfscanf(

        ( * __local_stdio_scanf_options ( ) ) | ( 1ULL << 0 ) ,

        _Stream, _Format, _Locale, _ArgList);

}











     

     int  vfscanf_s(

         FILE*       const _Stream,

          char const* const _Format,

                                      va_list           _ArgList

        )





    {

        return _vfscanf_s_l(_Stream, _Format, ( ( void * ) 0 ) , _ArgList);

    }









 

 int  _vscanf_l(

      char const* const _Format,

     _locale_t   const _Locale,

                                  va_list           _ArgList

    )





{

    return _vfscanf_l(( __acrt_iob_func ( 0 ) ) , _Format, _Locale, _ArgList);

}





 

 int  vscanf(

      char const* const _Format,

                                  va_list           _ArgList

    )





{

    return _vfscanf_l(( __acrt_iob_func ( 0 ) ) , _Format, ( ( void * ) 0 ) , _ArgList);

}





 

 int  _vscanf_s_l(

      char const* const _Format,

     _locale_t   const _Locale,

                                  va_list           _ArgList

    )





{

    return _vfscanf_s_l(( __acrt_iob_func ( 0 ) ) , _Format, _Locale, _ArgList);

}









     

     int  vscanf_s(

          char const* const _Format,

                                      va_list           _ArgList

        )





    {

        return _vfscanf_s_l(( __acrt_iob_func ( 0 ) ) , _Format, ( ( void * ) 0 ) , _ArgList);

    }









  

 int  _fscanf_l(

     FILE*       const _Stream,

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





  

 int  fscanf(

     FILE*       const _Stream,

      char const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfscanf_l(_Stream, _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  _fscanf_s_l(

     FILE*       const _Stream,

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}









     

     int  fscanf_s(

         FILE*       const _Stream,

          char const* const _Format,

        ...)





    {

        int _Result;

        va_list _ArgList;

        ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

        _Result = _vfscanf_s_l(_Stream, _Format, ( ( void * ) 0 ) , _ArgList);

        ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

        return _Result;

    }









  

 int  _scanf_l(

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfscanf_l(( __acrt_iob_func ( 0 ) ) , _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





  

 int  scanf(

      char const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfscanf_l(( __acrt_iob_func ( 0 ) ) , _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  _scanf_s_l(

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vfscanf_s_l(( __acrt_iob_func ( 0 ) ) , _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}









     

     int  scanf_s(

          char const* const _Format,

        ...)





    {

        int _Result;

        va_list _ArgList;

        ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

        _Result = _vfscanf_s_l(( __acrt_iob_func ( 0 ) ) , _Format, ( ( void * ) 0 ) , _ArgList);

        ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

        return _Result;

    }























 

 int  __stdio_common_vsprintf(

     unsigned __int64 _Options,

                 char*            _Buffer,

     size_t           _BufferCount,

       char const*      _Format,

     _locale_t        _Locale,

                                            va_list          _ArgList

    );



 

 int  __stdio_common_vsprintf_s(

     unsigned __int64 _Options,

                 char*            _Buffer,

     size_t           _BufferCount,

       char const*      _Format,

     _locale_t        _Locale,

                                            va_list          _ArgList

    );



 

 int  __stdio_common_vsnprintf_s(

     unsigned __int64 _Options,

                 char*            _Buffer,

     size_t           _BufferCount,

     size_t           _MaxCount,

       char const*      _Format,

     _locale_t        _Locale,

                                            va_list          _ArgList

    );



 

 int  __stdio_common_vsprintf_p(

     unsigned __int64 _Options,

                 char*            _Buffer,

     size_t           _BufferCount,

       char const*      _Format,

     _locale_t        _Locale,

                                            va_list          _ArgList

    );



 

  

 int  _vsnprintf_l(

                   char*       const _Buffer,

     size_t      const _BufferCount,

       char const* const _Format,

     _locale_t   const _Locale,

                                            va_list           _ArgList

    )





{

    int const _Result = __stdio_common_vsprintf(

        ( * __local_stdio_printf_options ( ) ) | ( 1ULL << 0 ) ,

        _Buffer, _BufferCount, _Format, _Locale, _ArgList);



    return _Result < 0 ? -1 : _Result;

}





 

 

 int  _vsnprintf(

       char*       const _Buffer,

     size_t      const _BufferCount,

      char const* const _Format,

                                             va_list           _ArgList

    )





{

    

    

    return _vsnprintf_l(_Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);

    

}













 

 

 int  vsnprintf(

         char*       const _Buffer,

     size_t      const _BufferCount,

      char const* const _Format,

                                  va_list           _ArgList

    )





{

    int const _Result = __stdio_common_vsprintf(

        ( * __local_stdio_printf_options ( ) ) | ( 1ULL << 1 ) ,

        _Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);



    return _Result < 0 ? -1 : _Result;

}





 

  

 int  _vsprintf_l(

      char*       const _Buffer,

     char const* const _Format,

     _locale_t   const _Locale,

                           va_list           _ArgList

    )





{

    

    

    return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

    

}





 

  

 int  vsprintf(

      char*       const _Buffer,

      char const* const _Format,

                                  va_list           _ArgList

    )





{

    

    

    return _vsnprintf_l(_Buffer, (size_t)-1, _Format, ( ( void * ) 0 ) , _ArgList);

    

}





 

 

 int  _vsprintf_s_l(

                 char*       const _Buffer,

     size_t      const _BufferCount,

       char const* const _Format,

     _locale_t   const _Locale,

                                            va_list           _ArgList

    )





{

    int const _Result = __stdio_common_vsprintf_s(

        ( * __local_stdio_printf_options ( ) ) ,

        _Buffer, _BufferCount, _Format, _Locale, _ArgList);



    return _Result < 0 ? -1 : _Result;

}









     

     

     int  vsprintf_s(

           char*       const _Buffer,

         size_t      const _BufferCount,

          char const* const _Format,

                                      va_list           _ArgList

        )





    {

        return _vsprintf_s_l(_Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);

    }



    

     







 

 

 int  _vsprintf_p_l(

                 char*       const _Buffer,

     size_t      const _BufferCount,

       char const* const _Format,

     _locale_t   const _Locale,

                                            va_list           _ArgList

    )





{

    int const _Result = __stdio_common_vsprintf_p(

        ( * __local_stdio_printf_options ( ) ) ,

        _Buffer, _BufferCount, _Format, _Locale, _ArgList);



    return _Result < 0 ? -1 : _Result;

}





 

 

 int  _vsprintf_p(

       char*       const _Buffer,

     size_t      const _BufferCount,

      char const* const _Format,

                                  va_list           _ArgList

    )





{

    return _vsprintf_p_l(_Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);

}





 

 

 int  _vsnprintf_s_l(

                 char*       const _Buffer,

     size_t      const _BufferCount,

     size_t      const _MaxCount,

       char const* const _Format,

     _locale_t   const _Locale,

                                            va_list          _ArgList

    )





{

    int const _Result = __stdio_common_vsnprintf_s(

        ( * __local_stdio_printf_options ( ) ) ,

        _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);



    return _Result < 0 ? -1 : _Result;

}





 

 

 int  _vsnprintf_s(

       char*       const _Buffer,

     size_t      const _BufferCount,

     size_t      const _MaxCount,

      char const* const _Format,

                                  va_list           _ArgList

    )





{

    return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ( ( void * ) 0 ) , _ArgList);

}





 







     

     

     int  vsnprintf_s(

           char*       const _Buffer,

         size_t      const _BufferCount,

         size_t      const _MaxCount,

          char const* const _Format,

                                      va_list           _ArgList

        )





    {

        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ( ( void * ) 0 ) , _ArgList);

    }



    

     







 

 int  _vscprintf_l(

       char const* const _Format,

     _locale_t   const _Locale,

                                            va_list           _ArgList

    )





{

    int const _Result = __stdio_common_vsprintf(

        ( * __local_stdio_printf_options ( ) ) | ( 1ULL << 1 ) ,

        ( ( void * ) 0 ) , 0, _Format, _Locale, _ArgList);



    return _Result < 0 ? -1 : _Result;

}





 

 int  _vscprintf(

      char const* const _Format,

                                  va_list           _ArgList

    )





{

    return _vscprintf_l(_Format, ( ( void * ) 0 ) , _ArgList);

}





 

 int  _vscprintf_p_l(

       char const* const _Format,

     _locale_t   const _Locale,

                                            va_list           _ArgList

    )





{

    int const _Result = __stdio_common_vsprintf_p(

        ( * __local_stdio_printf_options ( ) ) | ( 1ULL << 1 ) ,

        ( ( void * ) 0 ) , 0, _Format, _Locale, _ArgList);



    return _Result < 0 ? -1 : _Result;

}





 

 int  _vscprintf_p(

      char const* const _Format,

                                  va_list           _ArgList

    )





{

    return _vscprintf_p_l(_Format, ( ( void * ) 0 ) , _ArgList);

}





 

 int  _vsnprintf_c_l(

                   char*       const _Buffer,

     size_t      const _BufferCount,

       char const* const _Format,

     _locale_t   const _Locale,

                                            va_list           _ArgList

    )





{

    int const _Result = __stdio_common_vsprintf(

        ( * __local_stdio_printf_options ( ) ) ,

        _Buffer, _BufferCount, _Format, _Locale, _ArgList);



    return _Result < 0 ? -1 : _Result;

}





 

 

 int  _vsnprintf_c(

         char*       const _Buffer,

     size_t      const _BufferCount,

      char const* const _Format,

                                  va_list           _ArgList

    )





{

    return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);

}





  

 int  _sprintf_l(

      char*       const _Buffer,

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;



    

    

    _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);

    



    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 

 int  sprintf(

      char*       const _Buffer,

      char const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;



    

    

    _Result = _vsprintf_l(_Buffer, _Format, ( ( void * ) 0 ) , _ArgList);

    



    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}











 

 int sprintf ( 

 char * _Buffer , 

 char const * _Format 

 , ... ) ; 

 

 int vsprintf ( 

 char * _Buffer , 

 char const * _Format 

 , va_list _Args ) ; 





 

 

 int  _sprintf_s_l(

                 char*       const _Buffer,

     size_t      const _BufferCount,

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}









     

     

     int  sprintf_s(

           char*       const _Buffer,

         size_t      const _BufferCount,

          char const* const _Format,

        ...)





    {

        int _Result;

        va_list _ArgList;

        ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);

        ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

        return _Result;

    }









 



 

 

 int  _sprintf_p_l(

                 char*       const _Buffer,

     size_t      const _BufferCount,

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 

 int  _sprintf_p(

       char*       const _Buffer,

     size_t      const _BufferCount,

      char const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

  

 int  _snprintf_l(

                   char*       const _Buffer,

     size_t      const _BufferCount,

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;



    

    

    _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

    



    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}













 

 

 int  snprintf(

       char*       const _Buffer,

     size_t      const _BufferCount,

      char const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;



    _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  _snprintf(

       char*       const _Buffer,

     size_t      const _BufferCount,

      char const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;



    _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}







 

 int _snprintf ( 

 char * _Buffer , 

 size_t _BufferCount , 

 char const * _Format 

 , ... ) ; 

 

 int _vsnprintf ( 

 char * _Buffer , 

 size_t _BufferCount , 

 char const * _Format 

 , va_list _Args ) ; 



 

 

 int  _snprintf_c_l(

                   char*       const _Buffer,

     size_t      const _BufferCount,

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 

 int  _snprintf_c(

         char*       const _Buffer,

     size_t      const _BufferCount,

      char const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 

 int  _snprintf_s_l(

                 char*       const _Buffer,

     size_t      const _BufferCount,

     size_t      const _MaxCount,

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 

 int  _snprintf_s(

       char*       const _Buffer,

     size_t      const _BufferCount,

     size_t      const _MaxCount,

      char const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 



 

 int  _scprintf_l(

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vscprintf_l(_Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  _scprintf(

      char const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vscprintf_l(_Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  _scprintf_p_l(

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  _scprintf_p(

      char const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vscprintf_p(_Format, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}















 int  __stdio_common_vsscanf(

     unsigned __int64 _Options,

       char const*      _Buffer,

     size_t           _BufferCount,

       char const*      _Format,

     _locale_t        _Locale,

                                           va_list          _ArgList

    );



 

 int  _vsscanf_l(

     char const* const _Buffer,

      char const* const _Format,

     _locale_t   const _Locale,

                                  va_list           _ArgList

    )





{

    return __stdio_common_vsscanf(

        ( * __local_stdio_scanf_options ( ) ) ,

        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);

}





 

 int  vsscanf(

     char const* const _Buffer,

      char const* const _Format,

                                  va_list           _ArgList

    )





{

    return _vsscanf_l(_Buffer, _Format, ( ( void * ) 0 ) , _ArgList);

}





 

 int  _vsscanf_s_l(

     char const* const _Buffer,

      char const* const _Format,

     _locale_t   const _Locale,

                                  va_list           _ArgList

    )





{

    return __stdio_common_vsscanf(

        ( * __local_stdio_scanf_options ( ) ) | ( 1ULL << 0 ) ,

        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);

}









    

    



     

     int  vsscanf_s(

         char const* const _Buffer,

          char const* const _Format,

                                      va_list           _ArgList

        )





    {

        return _vsscanf_s_l(_Buffer, _Format, ( ( void * ) 0 ) , _ArgList);

    }





     

   

    







  

 int  _sscanf_l(

     char const* const _Buffer,

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





  

 int  sscanf(

     char const* const _Buffer,

      char const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vsscanf_l(_Buffer, _Format, ( ( void * ) 0 ) , _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  _sscanf_s_l(

     char const* const _Buffer,

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;

    _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);

    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}









     

     int  sscanf_s(

         char const* const _Buffer,

          char const* const _Format,

        ...)





    {

        int _Result;

        va_list _ArgList;

        ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;



        

        

        _Result = vsscanf_s(_Buffer, _Format, _ArgList);

        



        ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

        return _Result;

    }















  

 int  _snscanf_l(

       char const* const _Buffer,

     size_t      const _BufferCount,

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;



    _Result = __stdio_common_vsscanf(

        ( * __local_stdio_scanf_options ( ) ) ,

        _Buffer, _BufferCount, _Format, _Locale, _ArgList);



    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





  

 int  _snscanf(

       char const* const _Buffer,

     size_t      const _BufferCount,

      char const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;



    _Result = __stdio_common_vsscanf(

        ( * __local_stdio_scanf_options ( ) ) ,

        _Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);



    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}







 

 int  _snscanf_s_l(

       char const* const _Buffer,

     size_t      const _BufferCount,

       char const* const _Format,

     _locale_t   const _Locale,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Locale ) ) + ( ( sizeof ( _Locale ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;



    _Result = __stdio_common_vsscanf(

        ( * __local_stdio_scanf_options ( ) ) | ( 1ULL << 0 ) ,

        _Buffer, _BufferCount, _Format, _Locale, _ArgList);



    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}





 

 int  _snscanf_s(

       char const* const _Buffer,

     size_t      const _BufferCount,

      char const* const _Format,

    ...)





{

    int _Result;

    va_list _ArgList;

    ( ( void ) ( _ArgList = ( va_list ) ( & ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ) ) ;



    _Result = __stdio_common_vsscanf(

        ( * __local_stdio_scanf_options ( ) ) | ( 1ULL << 0 ) ,

        _Buffer, _BufferCount, _Format, ( ( void * ) 0 ) , _ArgList);



    ( ( void ) ( _ArgList = ( va_list ) 0 ) ) ;

    return _Result;

}

















































 

















































 













   

   

void*  _calloc_base(

     size_t _Count,

     size_t _Size

    );



   

    

void*  calloc(

      size_t _Count,

      size_t _Size

    );



 

 int  _callnewh(

     size_t _Size

    );



   

  

void*  _expand(

     void*  _Block,

      size_t _Size

    );



 

void  _free_base(

      void* _Block

    );



 

void  free(

      void* _Block

    );



   

   

void*  _malloc_base(

     size_t _Size

    );



   

    

void*  malloc(

      size_t _Size

    );



 

 

size_t  _msize(

     void* _Block

    );



     

   

void*  _realloc_base(

      void*  _Block,

     size_t _Size

    );



     

   

void*  realloc(

      void*  _Block,

      size_t _Size

    );



     

   

void*  _recalloc(

      void*  _Block,

      size_t _Count,

      size_t _Size

    );



 

void  _aligned_free(

      void* _Block

    );



   

   

void*  _aligned_malloc(

      size_t _Size,

     size_t _Alignment

    );



   

   

void*  _aligned_offset_malloc(

      size_t _Size,

     size_t _Alignment,

     size_t _Offset

    );



 

 

size_t  _aligned_msize(

     void*  _Block,

     size_t _Alignment,

     size_t _Offset

    );



     

   

void*  _aligned_offset_realloc(

      void*  _Block,

      size_t _Size,

     size_t _Alignment,

     size_t _Offset

    );



     

   

void*  _aligned_offset_recalloc(

      void*  _Block,

      size_t _Count,

      size_t _Size,

     size_t _Alignment,

     size_t _Offset

    );



     

   

void*  _aligned_realloc(

      void*  _Block,

      size_t _Size,

     size_t _Alignment

    );



     

   

void*  _aligned_recalloc(

      void*  _Block,

      size_t _Count,

      size_t _Size,

     size_t _Alignment

    );













 





















































 



















 int*  _errno(void);





 errno_t  _set_errno( int _Value);

 errno_t  _get_errno( int* _Value);



















    





 extern unsigned long   __threadid(void);



 extern uintptr_t  __threadhandle(void);







 





 











     

     void*  bsearch_s(

         void const* _Key,

          void const* _Base,

         rsize_t     _NumOfElements,

         rsize_t     _SizeOfElements,

         int ( * _PtFuncCompare)(void*, void const*, void const*),

         void*       _Context

        );



     void  qsort_s(

          void*   _Base,

         rsize_t _NumOfElements,

         rsize_t _SizeOfElements,

         int ( * _PtFuncCompare)(void*, void const*, void const*),

         void*   _Context

        );











 

 void*  bsearch(

     void const* _Key,

      void const* _Base,

     size_t      _NumOfElements,

     size_t      _SizeOfElements,

     int ( * _PtFuncCompare)(void const*, void const*)

    );



 void  qsort(

      void*  _Base,

     size_t _NumOfElements,

     size_t _SizeOfElements,

     int ( * _PtFuncCompare)(void const*, void const*)

    );



 

 void*  _lfind_s(

     void const*   _Key,

      void const*   _Base,

     unsigned int* _NumOfElements,

     size_t        _SizeOfElements,

     int ( * _PtFuncCompare)(void*, void const*, void const*), 

     void*         _Context

    );



 

 void*  _lfind(

     void const*   _Key,

      void const*   _Base,

     unsigned int* _NumOfElements,

     unsigned int  _SizeOfElements,

     int ( * _PtFuncCompare)(void const*, void const*)

    );



 

 void*  _lsearch_s(

     void const*   _Key,

      void*         _Base,

     unsigned int* _NumOfElements,

     size_t        _SizeOfElements,

     int ( * _PtFuncCompare)(void*, void const*, void const*),

     void*         _Context

    );



 

 void*  _lsearch(

     void const*   _Key,

      void*         _Base,

     unsigned int* _NumOfElements,

     unsigned int  _SizeOfElements,

     int ( * _PtFuncCompare)(void const*, void const*)

    );

































 



























 

































































 

 

 errno_t  _itow_s(

     int      _Value,

      wchar_t* _Buffer,

     size_t   _BufferCount,

     int      _Radix

    );



 





 wchar_t * _itow ( 

 int _Value , 

 wchar_t * _Buffer , 

 int _Radix 

 ) ; 



 

 

 errno_t  _ltow_s(

     long     _Value,

      wchar_t* _Buffer,

     size_t   _BufferCount,

     int      _Radix

    );



 





 wchar_t * _ltow ( 

 long _Value , 

 wchar_t * _Buffer , 

 int _Radix 

 ) ; 



 

 errno_t  _ultow_s(

     unsigned long _Value,

      wchar_t*      _Buffer,

     size_t        _BufferCount,

     int           _Radix

    );



 





 wchar_t * _ultow ( 

 unsigned long _Value , 

 wchar_t * _Buffer , 

 int _Radix 

 ) ; 



 

 double  wcstod(

     wchar_t const* _String,

      wchar_t**      _EndPtr

    );



 

 double  _wcstod_l(

     wchar_t const* _String,

      wchar_t**      _EndPtr,

     _locale_t      _Locale

    );



 

 long  wcstol(

     wchar_t const* _String,

      wchar_t**      _EndPtr,

     int            _Radix

    );



 

 long  _wcstol_l(

     wchar_t const* _String,

      wchar_t**      _EndPtr,

     int            _Radix,

     _locale_t      _Locale

    );



 

 long long  wcstoll(

     wchar_t const* _String,

      wchar_t**      _EndPtr,

     int            _Radix

    );



 

 long long  _wcstoll_l(

     wchar_t const* _String,

      wchar_t**      _EndPtr,

     int            _Radix,

     _locale_t      _Locale

    );



 

 unsigned long  wcstoul(

     wchar_t const* _String,

      wchar_t**      _EndPtr,

     int            _Radix

    );



 

 unsigned long  _wcstoul_l(

     wchar_t const* _String,

      wchar_t**      _EndPtr,

     int            _Radix,

     _locale_t      _Locale

    );



 

 unsigned long long  wcstoull(

     wchar_t const* _String,

      wchar_t**      _EndPtr,

     int            _Radix

    );



 

 unsigned long long  _wcstoull_l(

     wchar_t const* _String,

      wchar_t**      _EndPtr,

     int            _Radix,

     _locale_t      _Locale

    );



 

 long double  wcstold(

     wchar_t const* _String,

      wchar_t**      _EndPtr

    );



 

 long double  _wcstold_l(

     wchar_t const* _String,

      wchar_t**      _EndPtr,

     _locale_t      _Locale

    );



 

 float  wcstof(

     wchar_t const* _String,

      wchar_t**      _EndPtr

    );



 

 float  _wcstof_l(

     wchar_t const* _String,

      wchar_t**      _EndPtr,

     _locale_t      _Locale

    );



 

 double  _wtof(

     wchar_t const* _String

    );



 

 double  _wtof_l(

     wchar_t const* _String,

     _locale_t      _Locale

    );



 

 int  _wtoi(

     wchar_t const* _String

    );



 

 int  _wtoi_l(

     wchar_t const* _String,

     _locale_t      _Locale

    );



 

 long  _wtol(

     wchar_t const* _String

    );



 

 long  _wtol_l(

     wchar_t const* _String,

     _locale_t      _Locale

    );



 

 long long  _wtoll(

     wchar_t const* _String

    );



 

 long long  _wtoll_l(

     wchar_t const* _String,

     _locale_t      _Locale

    );



 

 errno_t  _i64tow_s(

     __int64  _Value,

      wchar_t* _Buffer,

     size_t   _BufferCount,

     int      _Radix

    );



 

 wchar_t*  _i64tow(

     __int64  _Value,

      wchar_t* _Buffer,

     int      _Radix

    );



 

 errno_t  _ui64tow_s(

     unsigned __int64 _Value,

      wchar_t*         _Buffer,

     size_t           _BufferCount,

     int              _Radix

    );



 

 wchar_t*  _ui64tow(

     unsigned __int64 _Value,

      wchar_t*         _Buffer,

     int              _Radix

    );



 

 __int64  _wtoi64(

     wchar_t const* _String

    );



 

 __int64  _wtoi64_l(

     wchar_t const* _String,

     _locale_t      _Locale

    );



 

 __int64  _wcstoi64(

     wchar_t const* _String,

      wchar_t**      _EndPtr,

     int            _Radix

    );



 

 __int64  _wcstoi64_l(

     wchar_t const* _String,

      wchar_t**      _EndPtr,

     int            _Radix,

     _locale_t      _Locale

    );



 

 unsigned __int64  _wcstoui64(

     wchar_t const* _String,

      wchar_t**      _EndPtr,

     int            _Radix

    );



 

 unsigned __int64  _wcstoui64_l(

     wchar_t const* _String,

      wchar_t**      _EndPtr,

     int            _Radix,

     _locale_t      _Locale

    );









 

 

  wchar_t*  _wfullpath(

      wchar_t*       _Buffer,

     wchar_t const* _Path,

     size_t         _BufferCount

    );







 

 errno_t  _wmakepath_s(

      wchar_t*       _Buffer,

     size_t         _BufferCount,

     wchar_t const* _Drive,

     wchar_t const* _Dir,

     wchar_t const* _Filename,

     wchar_t const* _Ext

    );



 





 void _wmakepath ( 

 wchar_t * _Buffer , 

 wchar_t const * _Drive , 

 wchar_t const * _Dir , 

 wchar_t const * _Filename , 

 wchar_t const * _Ext 

 ) ; 



 void  _wperror(

     wchar_t const* _ErrMsg

    );



 

 void  _wsplitpath(

     wchar_t const* _FullPath,

      wchar_t*       _Drive,

      wchar_t*       _Dir,

      wchar_t*       _Filename,

      wchar_t*       _Ext

    );



 errno_t  _wsplitpath_s(

     wchar_t const* _FullPath,

         wchar_t*       _Drive,

     size_t         _DriveCount,

           wchar_t*       _Dir,

     size_t         _DirCount,

      wchar_t*       _Filename,

     size_t         _FilenameCount,

           wchar_t*       _Ext,

     size_t         _ExtCount

    );



 











    

    



     

     errno_t  _wdupenv_s(

           wchar_t**      _Buffer,

         size_t*        _BufferCount,

         wchar_t const* _VarName

        );



    



      

     wchar_t*  _wgetenv(

         wchar_t const* _VarName

        );



     

     

     errno_t  _wgetenv_s(

         size_t*        _RequiredCount,

          wchar_t*       _Buffer,

         size_t         _BufferCount,

         wchar_t const* _VarName

        );



     



     

     int  _wputenv(

         wchar_t const* _EnvString

        );



     

     errno_t  _wputenv_s(

         wchar_t const* _Name,

         wchar_t const* _Value

        );

    

     errno_t  _wsearchenv_s(

         wchar_t const* _Filename,

         wchar_t const* _VarName,

          wchar_t*       _Buffer,

         size_t         _BufferCount

        );

    

     

    

    

 void _wsearchenv ( 

 wchar_t const * _Filename , 

 wchar_t const * _VarName , 

 wchar_t * _ResultPath 

 ) ; 



     int  _wsystem(

         wchar_t const* _Command

        );











 

















































































































































































































































































































































































































































 



















    

    



























































































    





        

    







    

        

    









 





 









    





















 void  _swab(

        char* _Buf1,

        char* _Buf2,

     int   _SizeInBytes

    );

























   void  exit( int _Code);

   void  _exit( int _Code);

   void  _Exit( int _Code);

   void  quick_exit( int _Code);

   void  abort(void);











 unsigned int  _set_abort_behavior(

     unsigned int _Flags,

     unsigned int _Mask

    );









    typedef int ( * _onexit_t)(void);

























































    int        atexit(void ( *)(void));

    _onexit_t  _onexit( _onexit_t _Func);





int  at_quick_exit(void ( *)(void));



















    

    typedef void ( * _purecall_handler)(void);



    

    typedef void ( * _invalid_parameter_handler)(

        wchar_t const*,

        wchar_t const*,

        wchar_t const*, 

        unsigned int,

        uintptr_t

        );



    

     _purecall_handler  _set_purecall_handler(

         _purecall_handler _Handler

        );



     _purecall_handler  _get_purecall_handler(void);



    

     _invalid_parameter_handler  _set_invalid_parameter_handler(

         _invalid_parameter_handler _Handler

        );



     _invalid_parameter_handler  _get_invalid_parameter_handler(void);



     _invalid_parameter_handler  _set_thread_local_invalid_parameter_handler(

         _invalid_parameter_handler _Handler

        );



     _invalid_parameter_handler  _get_thread_local_invalid_parameter_handler(void);





























  int  _set_error_mode( int _Mode);







 int*  _errno(void);





 errno_t  _set_errno( int _Value);

 errno_t  _get_errno( int* _Value);



 unsigned long*  __doserrno(void);





 errno_t  _set_doserrno( unsigned long _Value);

 errno_t  _get_doserrno( unsigned long * _Value);





   char**  __sys_errlist(void);





   int *  __sys_nerr(void);





 void  perror( char const* _ErrMsg);









   char**     __p__pgmptr (void);

   wchar_t**  __p__wpgmptr(void);

   int*       __p__fmode  (void);







    

    

    





 

 errno_t  _get_pgmptr ( char**    _Value);



 

 errno_t  _get_wpgmptr( wchar_t** _Value);



 errno_t  _set_fmode  ( int       _Mode );



 errno_t  _get_fmode  ( int*      _PMode);

















typedef struct _div_t

{

    int quot;

    int rem;

} div_t;



typedef struct _ldiv_t

{

    long quot;

    long rem;

} ldiv_t;



typedef struct _lldiv_t

{

    long long quot;

    long long rem;

} lldiv_t;



 int        abs   ( int       _Number);

 long       labs  ( long      _Number);

 long long  llabs ( long long _Number);

 __int64    _abs64( __int64   _Number);



 unsigned short    _byteswap_ushort( unsigned short   _Number);

 unsigned long     _byteswap_ulong ( unsigned long    _Number);

 unsigned __int64  _byteswap_uint64( unsigned __int64 _Number);



  div_t    div  ( int       _Numerator,  int       _Denominator);

  ldiv_t   ldiv ( long      _Numerator,  long      _Denominator);

  lldiv_t  lldiv( long long _Numerator,  long long _Denominator);













unsigned int  _rotl(

     unsigned int _Value,

     int          _Shift

    );



 

unsigned long  _lrotl(

     unsigned long _Value,

     int           _Shift

    );



unsigned __int64  _rotl64(

     unsigned __int64 _Value,

     int              _Shift

    );



unsigned int  _rotr(

     unsigned int _Value,

     int          _Shift

    );



 

unsigned long  _lrotr(

     unsigned long _Value,

     int           _Shift

    );



unsigned __int64  _rotr64(

     unsigned __int64 _Value,

     int              _Shift

    );

















 void  srand( unsigned int _Seed);



  int  rand(void);





































    

    typedef struct

    {

        unsigned char ld[10];

    } _LDOUBLE;

    



    











typedef struct

{

    double x;

} _CRT_DOUBLE;



typedef struct

{

    float f;

} _CRT_FLOAT;











typedef struct

{

    long double x;

} _LONGDOUBLE;









typedef struct

{

    unsigned char ld12[12];

} _LDBL12;



















  double     atof   ( char const* _String);

   int        atoi   ( char const* _String);

  long       atol   ( char const* _String);

  long long  atoll  ( char const* _String);

  __int64    _atoi64( char const* _String);



  double     _atof_l  ( char const* _String,  _locale_t _Locale);

  int        _atoi_l  ( char const* _String,  _locale_t _Locale);

  long       _atol_l  ( char const* _String,  _locale_t _Locale);

  long long  _atoll_l ( char const* _String,  _locale_t _Locale);

  __int64    _atoi64_l( char const* _String,  _locale_t _Locale);



  int  _atoflt ( _CRT_FLOAT*  _Result,  char const* _String);

  int  _atodbl ( _CRT_DOUBLE* _Result,  char*       _String);

  int  _atoldbl( _LDOUBLE*    _Result,  char*       _String);



 

 int  _atoflt_l(

     _CRT_FLOAT* _Result,

     char const* _String,

     _locale_t   _Locale

    );



 

 int  _atodbl_l(

     _CRT_DOUBLE* _Result,

     char*        _String,

     _locale_t    _Locale

    );





 

 int  _atoldbl_l(

     _LDOUBLE* _Result,

     char*     _String,

     _locale_t _Locale

    );



 

 float  strtof(

     char const* _String,

      char**      _EndPtr

    );



 

 float  _strtof_l(

     char const* _String,

      char**      _EndPtr,

     _locale_t   _Locale

    );



 

 double  strtod(

     char const* _String,

      char**      _EndPtr

    );



 

 double  _strtod_l(

     char const* _String,

      char**      _EndPtr,

     _locale_t   _Locale

    );



 

 long double  strtold(

     char const* _String,

      char**      _EndPtr

    );



 

 long double  _strtold_l(

     char const* _String,

      char**      _EndPtr,

     _locale_t   _Locale

    );



 

 long  strtol(

     char const* _String,

      char**      _EndPtr,

     int         _Radix

    );



 

 long  _strtol_l(

     char const* _String,

      char**      _EndPtr,

     int         _Radix,

     _locale_t   _Locale

    );



 

 long long  strtoll(

     char const* _String,

      char**      _EndPtr,

     int         _Radix

    );



 

 long long  _strtoll_l(

     char const* _String,

      char**      _EndPtr,

     int         _Radix,

     _locale_t   _Locale

    );



 

 unsigned long  strtoul(

     char const* _String,

      char**      _EndPtr,

     int         _Radix

    );



 

 unsigned long  _strtoul_l(

     char const* _String,

      char**      _EndPtr,

     int         _Radix,

     _locale_t   _Locale

    );



 

 unsigned long long  strtoull(

     char const* _String,

      char**      _EndPtr,

     int         _Radix

    );



 

 unsigned long long  _strtoull_l(

     char const* _String,

      char**      _EndPtr,

     int         _Radix,

     _locale_t   _Locale

    );



 

 __int64  _strtoi64(

     char const* _String,

      char**      _EndPtr,

     int         _Radix

    );



 

 __int64  _strtoi64_l(

     char const* _String,

      char**      _EndPtr,

     int         _Radix,

     _locale_t   _Locale

    );



 

 unsigned __int64  _strtoui64(

     char const* _String,

      char**      _EndPtr,

     int         _Radix

    );



 

 unsigned __int64  _strtoui64_l(

     char const* _String,

      char**      _EndPtr,

     int         _Radix,

     _locale_t   _Locale

    );

















 

 

 errno_t  _itoa_s(

     int    _Value,

      char*  _Buffer,

     size_t _BufferCount,

     int    _Radix

    );



 





 char * _itoa ( 

 int _Value , 

 char * _Buffer , 

 int _Radix 

 ) ; 



 

 

 errno_t  _ltoa_s(

     long   _Value,

      char*  _Buffer,

     size_t _BufferCount,

     int    _Radix

    );



 





 char * _ltoa ( 

 long _Value , 

 char * _Buffer , 

 int _Radix 

 ) ; 



 

 

 errno_t  _ultoa_s(

     unsigned long _Value,

      char*         _Buffer,

     size_t        _BufferCount,

     int           _Radix

    );



 





 char * _ultoa ( 

 unsigned long _Value , 

 char * _Buffer , 

 int _Radix 

 ) ; 



 

 

 errno_t  _i64toa_s(

     __int64 _Value,

      char*   _Buffer,

     size_t  _BufferCount,

     int     _Radix

    );



 

 

 char*  _i64toa(

     __int64 _Value,

      char*   _Buffer,

     int     _Radix

    );



 

 

 errno_t  _ui64toa_s(

     unsigned __int64 _Value,

      char*            _Buffer,

     size_t           _BufferCount,

     int              _Radix

    );



 

 char*  _ui64toa(

     unsigned __int64 _Value,

      char*            _Buffer,

     int              _Radix

    );



























 

 

 errno_t  _ecvt_s(

      char* _Buffer,

     size_t                       _BufferCount,

     double                       _Value,

     int                          _DigitCount,

     int*                         _PtDec,

     int*                         _PtSign

    );



 



  

 char*  _ecvt(

     double _Value,

     int    _DigitCount,

     int*   _PtDec,

     int*   _PtSign

    );



 

 

 errno_t  _fcvt_s(

      char*  _Buffer,

     size_t _BufferCount,

     double _Value,

     int    _FractionalDigitCount,

     int*   _PtDec,

     int*   _PtSign

    );



 



 

  

 char*  _fcvt(

     double _Value,

     int    _FractionalDigitCount,

     int*   _PtDec,

     int*   _PtSign

    );



 

 errno_t  _gcvt_s(

      char*  _Buffer,

     size_t _BufferCount,

     double _Value,

     int    _DigitCount

    );



 



 

 char*  _gcvt(

     double _Value,

     int    _DigitCount,

      char*  _Buffer

    );























    





        

    



    



        

    



     

     int  ___mb_cur_max_func(void);



     

     int  ___mb_cur_max_l_func(_locale_t);









 

 int  mblen(

       char const* _Ch,

     size_t      _MaxCount

    );



 

 int  _mblen_l(

       char const* _Ch,

     size_t      _MaxCount,

     _locale_t   _Locale

    );



 

 

 size_t  _mbstrlen(

     char const* _String

    );



 

 

 size_t  _mbstrlen_l(

     char const* _String, 

     _locale_t   _Locale

    );



 

 

 size_t  _mbstrnlen(

     char const* _String,

     size_t      _MaxCount

    );



 

 

 size_t  _mbstrnlen_l(

     char const* _String,

     size_t      _MaxCount,

     _locale_t   _Locale

    );



 

 int  mbtowc(

      wchar_t*    _DstCh,

      char const* _SrcCh,

     size_t      _SrcSizeInBytes

    );



 

 int  _mbtowc_l(

      wchar_t*    _DstCh,

      char const* _SrcCh,

     size_t      _SrcSizeInBytes,

     _locale_t   _Locale

    );



 

 errno_t  mbstowcs_s(

     size_t*     _PtNumOfCharConverted,

      wchar_t*    _DstBuf,

     size_t      _SizeInWords,

                                     char const* _SrcBuf,

     size_t      _MaxCount

    );



 





 size_t mbstowcs ( 

 wchar_t * _Dest , 

 char const * _Source , 

 size_t _MaxCount 

 ) ; 



 

 errno_t  _mbstowcs_s_l(

     size_t*     _PtNumOfCharConverted,

      wchar_t*    _DstBuf,

     size_t      _SizeInWords,

                                     char const* _SrcBuf,

     size_t      _MaxCount,

     _locale_t   _Locale

    );



 





 size_t _mbstowcs_l ( 

 wchar_t * _Dest , 

 char const * _Source , 

 size_t _MaxCount , 

 _locale_t _Locale 

 ) ; 









 

 int  wctomb(

      char*   _MbCh,

     wchar_t _WCh

    );



 

 int  _wctomb_l(

      char*     _MbCh,

     wchar_t   _WCh,

     _locale_t _Locale

    );







     

     errno_t  wctomb_s(

         int*    _SizeConverted,

          char*   _MbCh,

         rsize_t _SizeInBytes,

         wchar_t _WCh

        );







 

 errno_t  _wctomb_s_l(

     int*     _SizeConverted,

      char*     _MbCh,

     size_t    _SizeInBytes,

     wchar_t   _WCh, 

     _locale_t _Locale);



 

 errno_t  wcstombs_s(

     size_t*        _PtNumOfCharConverted,

      char*          _Dst,

     size_t         _DstSizeInBytes,

     wchar_t const* _Src,

     size_t         _MaxCountInBytes

    );



 





 size_t wcstombs ( 

 char * _Dest , 

 wchar_t const * _Source , 

 size_t _MaxCount 

 ) ; 



 

 errno_t  _wcstombs_s_l(

     size_t*        _PtNumOfCharConverted,

      char*          _Dst,

     size_t         _DstSizeInBytes,

     wchar_t const* _Src,

     size_t         _MaxCountInBytes,

     _locale_t      _Locale

    );



 





 size_t _wcstombs_l ( 

 char * _Dest , 

 wchar_t const * _Source , 

 size_t _MaxCount , 

 _locale_t _Locale 

 ) ; 









































 

 

  char*  _fullpath(

      char*       _Buffer,

     char const* _Path,

     size_t      _BufferCount

    );







 

 errno_t  _makepath_s(

      char*       _Buffer,

     size_t      _BufferCount,

     char const* _Drive,

     char const* _Dir,

     char const* _Filename,

     char const* _Ext

    );



 





 void _makepath ( 

 char * _Buffer , 

 char const * _Drive , 

 char const * _Dir , 

 char const * _Filename , 

 char const * _Ext 

 ) ; 



 

 void  _splitpath(

     char const* _FullPath,

      char*       _Drive,

      char*       _Dir,

      char*       _Filename,

      char*       _Ext

    );



 

 errno_t  _splitpath_s(

     char const* _FullPath,

         char*       _Drive,

     size_t      _DriveCount,

           char*       _Dir,

     size_t      _DirCount,

      char*       _Filename,

     size_t      _FilenameCount,

           char*       _Ext,

     size_t      _ExtCount

    );



 





















    



     

     

     errno_t  getenv_s(

         size_t*     _RequiredCount,

          char*       _Buffer,

         rsize_t     _BufferCount,

         char const* _VarName

        );

    

    









     int*        __p___argc (void);

     char***     __p___argv (void);

     wchar_t***  __p___wargv(void);



    



        

        

        

    

    

     char***     __p__environ (void);

     wchar_t***  __p__wenviron(void);



    

        

    

    

    







        

        

    







    

    







       

     char*  getenv(

         char const* _VarName

        );



     



    





     

     errno_t  _dupenv_s(

           char**      _Buffer,

         size_t*     _BufferCount,

         char const* _VarName

        );



    





     int  system(

         char const* _Command

        );



    

    

    

    



     

     int  _putenv(

         char const* _EnvString

        );



     

     errno_t  _putenv_s(

         char const* _Name,

         char const* _Value

        );



    



     errno_t  _searchenv_s(

         char const* _Filename,

         char const* _VarName,

          char*       _Buffer,

         size_t      _BufferCount

        );



     



    

 void _searchenv ( 

 char const * _Filename , 

 char const * _VarName , 

 char * _Buffer 

 ) ; 



    

     

     void  _seterrormode(

         int _Mode

        );



     

     void  _beep(

         unsigned _Frequency,

         unsigned _Duration

        );



     

     void  _sleep(

         unsigned long _Duration

        );

















































 





























typedef enum 

{

    RESULT_OK = 0,

    RESULT_OUT_OF_MEM,

    RESULT_FAIL

} Result;



















































































































































































































































































































































































































































































































    









        

    







    





        





            

        

    







    





        





            

        

    







    









        





            

        

    









typedef struct

{

    void** pItems;

    size_t size;

    size_t capacity;



} Array;



Result Array_Reserve(Array* p, size_t nelements);

void Array_Pop(Array* p, void(*pfDestroyData)(void*));

void* Array_Top(Array* p);

Result Array_Push(Array* p, void* pItem);

void Array_Clear(Array* p, void(*pfDestroyData)(void*));

Result Array_Init(Array* p);

Result Array_Create(Array** pp);

void Array_Destroy(Array* st, void(*pfDestroyData)(void*));

void Array_Delete(Array* st, void(*pfDestroyData)(void*));

void Array_Swap(Array* p1, Array* p2);







typedef struct

{

    const char** pItems;

    size_t size;

    size_t capacity;



} StrArray;







Result StrArray_Reserve(StrArray* p, size_t nelements);

Result StrArray_Push(StrArray* p, const char* pItem);

void StrArray_Clear(StrArray* p);

Result StrArray_Init(StrArray* p);



void StrArray_Destroy(StrArray* st);









typedef struct

{

    int* pItems;

    size_t size;

    size_t capacity;



} ArrayInt;



Result ArrayInt_Reserve(ArrayInt* p, size_t nelements);



_Bool ArrayInt_IsEmpty(ArrayInt* p);



int ArrayInt_Pop(ArrayInt* p);



int ArrayInt_Top(ArrayInt* p);



Result ArrayInt_Push(ArrayInt* p, int pItem);



void ArrayInt_Clear(ArrayInt* p);



Result ArrayInt_Init(ArrayInt* p);



Result ArrayInt_Create(ArrayInt** pp);



void ArrayInt_Destroy(ArrayInt* st);



void ArrayInt_Delete(ArrayInt* st);























































































































































 







 extern int*  _errno(void);





 errno_t  _set_errno( int _Value);

 errno_t  _get_errno( int* _Value);







 unsigned long*  __doserrno(void);





 errno_t  _set_doserrno( unsigned long _Value);

 errno_t  _get_doserrno( unsigned long * _Value);





















































































    

    

    

    

    















    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    









 



















































































































































































































































































































































































































































 







 

 void  *  memchr(

      void const* _Buf,

     int         _Val,

     size_t      _MaxCount

    );



 

int  memcmp(

      void const* _Buf1,

      void const* _Buf2,

     size_t      _Size

    );



 

 

 

void*  memcpy(

      void* _Dst,

            void const* _Src,

     size_t      _Size

    );



 

 void*  memmove(

      void*       _Dst,

            void const* _Src,

     size_t      _Size

    );



 

 

void*  memset(

      void*  _Dst,

     int    _Val,

     size_t _Size

    );



 

 char  *  strchr(

     char const* _Str,

     int         _Val

    );



 

 char  *  strrchr(

     char const* _Str,

     int         _Ch

    );



  

 char  *  strstr(

     char const* _Str,

     char const* _SubStr

    );



 

 

 wchar_t  *  wcschr(

     wchar_t const* _Str,

     wchar_t        _Ch

    );



 

 wchar_t  *  wcsrchr(

     wchar_t const* _Str,

     wchar_t        _Ch

    );



  

 

 wchar_t  *  wcsstr(

     wchar_t const* _Str,

     wchar_t const* _SubStr

    );







 









 





    













     

     

    static errno_t  memcpy_s(

          void*       const _Destination,

         rsize_t     const _DestinationSize,

                                 void const* const _Source,

         rsize_t     const _SourceSize

        )

    {

        if (_SourceSize == 0)

        {

            return 0;

        }



        { int _Expr_val = ! ! ( _Destination != ( ( void * ) 0 ) ) ; if ( ! ( _Expr_val ) ) { ( * _errno ( ) ) = 22 ; _invalid_parameter_noinfo ( ) ; return 22 ; } } ;

        if (_Source == ( ( void * ) 0 ) || _DestinationSize < _SourceSize)

        {

            memset(_Destination, 0, _DestinationSize);



            { int _Expr_val = ! ! ( _Source != ( ( void * ) 0 ) ) ; if ( ! ( _Expr_val ) ) { ( * _errno ( ) ) = 22 ; _invalid_parameter_noinfo ( ) ; return 22 ; } } ;

            { int _Expr_val = ! ! ( _DestinationSize >= _SourceSize ) ; if ( ! ( _Expr_val ) ) { ( * _errno ( ) ) = 34 ; _invalid_parameter_noinfo ( ) ; return 34 ; } } ;



            

            return 22 ;

        }



        memcpy(_Destination, _Source, _SourceSize);

        return 0;

    }



     

    static errno_t  memmove_s(

          void*       const _Destination,

         rsize_t     const _DestinationSize,

                                 void const* const _Source,

         rsize_t     const _SourceSize

        )

    {

        if (_SourceSize == 0)

        {

            return 0;

        }



        { int _Expr_val = ! ! ( _Destination != ( ( void * ) 0 ) ) ; if ( ! ( _Expr_val ) ) { ( * _errno ( ) ) = 22 ; _invalid_parameter_noinfo ( ) ; return 22 ; } } ;

        { int _Expr_val = ! ! ( _Source != ( ( void * ) 0 ) ) ; if ( ! ( _Expr_val ) ) { ( * _errno ( ) ) = 22 ; _invalid_parameter_noinfo ( ) ; return 22 ; } } ;

        { int _Expr_val = ! ! ( _DestinationSize >= _SourceSize ) ; if ( ! ( _Expr_val ) ) { ( * _errno ( ) ) = 34 ; _invalid_parameter_noinfo ( ) ; return 34 ; } } ;



        memmove(_Destination, _Source, _SourceSize);

        return 0;

    }











 











 







 

 int  _memicmp(

      void const* _Buf1,

      void const* _Buf2,

     size_t      _Size

    );



 

 int  _memicmp_l(

      void const* _Buf1,

      void const* _Buf2,

     size_t      _Size,

     _locale_t   _Locale

    );











    





    

































 





































 





















     

     errno_t  wcscat_s(

          wchar_t* _Destination,

         rsize_t _SizeInWords,

         wchar_t const* _Source

        );



     

     errno_t  wcscpy_s(

          wchar_t* _Destination,

         rsize_t _SizeInWords,

         wchar_t const* _Source

        );

    

     

     errno_t  wcsncat_s(

          wchar_t*       _Destination,

         rsize_t        _SizeInWords,

               wchar_t const* _Source,

         rsize_t        _MaxCount

        );

    

     

     errno_t  wcsncpy_s(

          wchar_t*       _Destination,

         rsize_t        _SizeInWords,

            wchar_t const* _Source,

         rsize_t        _MaxCount

        );

    

     

     wchar_t*  wcstok_s(

         wchar_t*       _String,

         wchar_t const* _Delimiter,

          wchar_t**      _Context

        );



























 

  wchar_t*  _wcsdup(

     wchar_t const* _String

    );













 







    

 wchar_t * wcscat ( 

 wchar_t * _Destination , 

 wchar_t const * _Source 

 ) ; 







 

 int  wcscmp(

     wchar_t const* _String1,

     wchar_t const* _String2

    );



 





 wchar_t * wcscpy ( 

 wchar_t * _Destination , 

 wchar_t const * _Source 

 ) ; 



 

 size_t  wcscspn(

     wchar_t const* _String,

     wchar_t const* _Control

    );



 

 size_t  wcslen(

     wchar_t const* _String

    );



 

 

 

 size_t  wcsnlen(

      wchar_t const* _Source,

     size_t         _MaxCount

    );







     

     

     

    static  size_t  wcsnlen_s(

          wchar_t const* _Source,

         size_t         _MaxCount

        )

    {

        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);

    }







 





 wchar_t * wcsncat ( 

 wchar_t * _Destination , 

 wchar_t const * _Source , 

 size_t _Count 

 ) ; 



 

 int  wcsncmp(

      wchar_t const* _String1,

      wchar_t const* _String2,

     size_t         _MaxCount

    );



 





 wchar_t * wcsncpy ( 

 wchar_t * _Destination , 

 wchar_t const * _Source , 

 size_t _Count 

 ) ; 



 

 wchar_t  *  wcspbrk(

     wchar_t const* _String,

     wchar_t const* _Control

    );



 

 size_t  wcsspn(

     wchar_t const* _String,

     wchar_t const* _Control

    );



  

 wchar_t*  wcstok(

     wchar_t*       _String,

     wchar_t const* _Delimiter,

      wchar_t**      _Context

    );







    





        

    



    

    



      

    static  wchar_t*  _wcstok(

         wchar_t*       const _String,

         wchar_t const* const _Delimiter

        )

    {

        return wcstok(_String, _Delimiter, 0);

    }



    







    





    











 

  

 wchar_t*  _wcserror(

     int _ErrorNumber

    );



 

 errno_t  _wcserror_s(

      wchar_t* _Buffer,

     size_t   _SizeInWords,

     int      _ErrorNumber

    );



 



 

 

  

 wchar_t*  __wcserror(

     wchar_t const* _String

    );



  errno_t  __wcserror_s(

      wchar_t*       _Buffer,

     size_t         _SizeInWords,

     wchar_t const* _ErrorMessage

    );



 



  int  _wcsicmp(

     wchar_t const* _String1,

     wchar_t const* _String2

    );



  int  _wcsicmp_l(

     wchar_t const* _String1,

     wchar_t const* _String2,

     _locale_t      _Locale

    );



  int  _wcsnicmp(

      wchar_t const* _String1,

      wchar_t const* _String2,

     size_t         _MaxCount

    );



  int  _wcsnicmp_l(

      wchar_t const* _String1,

      wchar_t const* _String2,

     size_t         _MaxCount,

     _locale_t      _Locale

    );



  errno_t  _wcsnset_s(

      wchar_t* _Destination,

     size_t   _SizeInWords,

     wchar_t  _Value,

     size_t   _MaxCount

    );



 





 wchar_t * _wcsnset ( 

 wchar_t * _String , 

 wchar_t _Value , 

 size_t _MaxCount 

 ) ; 



 wchar_t*  _wcsrev(

     wchar_t* _String

    );



  errno_t  _wcsset_s(

      wchar_t* _Destination,

     size_t   _SizeInWords,

     wchar_t  _Value

    );



 





 wchar_t * _wcsset ( 

 wchar_t * _String , 

 wchar_t _Value 

 ) ; 



  errno_t  _wcslwr_s(

      wchar_t* _String,

     size_t   _SizeInWords

    );



 





 wchar_t * _wcslwr ( 

 wchar_t * _String 

 ) ; 



 

 errno_t  _wcslwr_s_l(

      wchar_t*  _String,

     size_t    _SizeInWords,

     _locale_t _Locale

    );



 





 wchar_t * _wcslwr_l ( 

 wchar_t * _String , 

 _locale_t _Locale 

 ) ; 



 

 errno_t  _wcsupr_s(

      wchar_t* _String,

     size_t   _Size

    );



 





 wchar_t * _wcsupr ( 

 wchar_t * _String 

 ) ; 



 

 errno_t  _wcsupr_s_l(

      wchar_t*  _String,

     size_t    _Size,

     _locale_t _Locale

    );



 





 wchar_t * _wcsupr_l ( 

 wchar_t * _String , 

 _locale_t _Locale 

 ) ; 



 

 

 size_t  wcsxfrm(

       wchar_t*       _Destination,

     wchar_t const* _Source,

               size_t         _MaxCount

    );



 

 

 size_t  _wcsxfrm_l(

       wchar_t*       _Destination,

     wchar_t const* _Source,

               size_t         _MaxCount,

     _locale_t      _Locale

    );



 

 int  wcscoll(

     wchar_t const* _String1,

     wchar_t const* _String2

    );



 

 int  _wcscoll_l(

     wchar_t const* _String1,

     wchar_t const* _String2,

     _locale_t      _Locale

    );



 

 int  _wcsicoll(

     wchar_t const* _String1,

     wchar_t const* _String2

    );



 

 int  _wcsicoll_l(

     wchar_t const* _String1,

     wchar_t const* _String2,

     _locale_t      _Locale

    );



 

 int  _wcsncoll(

      wchar_t const* _String1,

      wchar_t const* _String2,

     size_t         _MaxCount

    );



 

 int  _wcsncoll_l(

      wchar_t const* _String1,

      wchar_t const* _String2,

     size_t         _MaxCount,

     _locale_t      _Locale

    );



 

 int  _wcsnicoll(

      wchar_t const* _String1,

      wchar_t const* _String2,

     size_t         _MaxCount

    );



 

 int  _wcsnicoll_l(

      wchar_t const* _String1,

      wchar_t const* _String2,

     size_t         _MaxCount,

     _locale_t      _Locale

    );

























































 















 















     

     errno_t  strcpy_s(

          char*       _Destination,

         rsize_t     _SizeInBytes,

         char const* _Source

        );



     

     errno_t  strcat_s(

          char*       _Destination,

         rsize_t     _SizeInBytes,

         char const* _Source

        );



     

     errno_t  strerror_s(

          char*  _Buffer,

         size_t _SizeInBytes,

         int    _ErrorNumber);



     

     errno_t  strncat_s(

          char*       _Destination,

         rsize_t     _SizeInBytes,

               char const* _Source,

         rsize_t     _MaxCount

        );



     

     errno_t  strncpy_s(

          char*       _Destination,

         rsize_t     _SizeInBytes,

            char const* _Source,

         rsize_t     _MaxCount

        );



     

     char*   strtok_s(

         char*       _String,

         char const* _Delimiter,

          char**      _Context

        );







 void*  _memccpy(

      void*       _Dst,

     void const* _Src,

     int         _Val,

     size_t      _MaxCount

    );



 







    

 char * strcat ( 

 char * _Destination , 

 char const * _Source 

 ) ; 







 

int  strcmp(

     char const* _Str1,

     char const* _Str2

    );



 

 int  _strcmpi(

     char const* _String1,

     char const* _String2

    );



 

 int  strcoll(

     char const* _String1,

     char const* _String2

    );



 

 int  _strcoll_l(

     char const* _String1,

     char const* _String2,

     _locale_t   _Locale

    );



char*  strcpy(

      char*       _Dest,

     char const* _Source

    );



 





 char * strcpy ( 

 char * _Destination , 

 char const * _Source 

 ) ; 



 

 size_t  strcspn(

     char const* _Str,

     char const* _Control

    );









 

  char*  _strdup(

     char const* _Source

    );









 

 

  

 char*   _strerror(

     char const* _ErrorMessage

    );



 

 errno_t  _strerror_s(

      char*       _Buffer,

     size_t      _SizeInBytes,

     char const* _ErrorMessage

    );



 



 

  

 char*  strerror(

     int _ErrorMessage

    );



 



 

 int  _stricmp(

     char const* _String1,

     char const* _String2

    );



 

 int  _stricoll(

     char const* _String1,

     char const* _String2

    );



 

 int  _stricoll_l(

     char const* _String1,

     char const* _String2,

     _locale_t   _Locale

    );



 

 int  _stricmp_l(

     char const* _String1,

     char const* _String2,

     _locale_t   _Locale

    );



 

size_t  strlen(

     char const* _Str

    );



 

 errno_t  _strlwr_s(

      char*  _String,

     size_t _Size

    );



 





 char * _strlwr ( 

 char * _String 

 ) ; 



 

 errno_t  _strlwr_s_l(

      char*     _String,

     size_t    _Size,

     _locale_t _Locale

    );



 





 char * _strlwr_l ( 

 char * _String , 

 _locale_t _Locale 

 ) ; 



 char*  strncat(

      char*       _Dest,

        char const* _Source,

     size_t      _Count

    );



 





 char * strncat ( 

 char * _Destination , 

 char const * _Source , 

 size_t _Count 

 ) ; 



 

 int  strncmp(

      char const* _Str1,

      char const* _Str2,

     size_t      _MaxCount

    );



 

 int  _strnicmp(

      char const* _String1,

      char const* _String2,

     size_t      _MaxCount

    );



 

 int  _strnicmp_l(

      char const* _String1,

      char const* _String2,

     size_t      _MaxCount,

     _locale_t   _Locale

    );



 

 int  _strnicoll(

      char const* _String1,

      char const* _String2,

     size_t      _MaxCount

    );



 

 int  _strnicoll_l(

      char const* _String1,

      char const* _String2,

     size_t      _MaxCount,

     _locale_t   _Locale

    );



 

 int  _strncoll(

      char const* _String1,

      char const* _String2,

     size_t      _MaxCount

    );



 

 int  _strncoll_l(

      char const* _String1,

      char const* _String2,

     size_t      _MaxCount,

     _locale_t   _Locale

    );



 size_t  __strncnt(

      char const* _String,

     size_t      _Count

    );



 





 char * strncpy ( 

 char * _Destination , 

 char const * _Source , 

 size_t _Count 

 ) ; 



 

 

 

 size_t  strnlen(

      char const* _String,

     size_t      _MaxCount

    );







     

     

     

    static  size_t  strnlen_s(

          char const* _String,

         size_t      _MaxCount

        )

    {

        return _String == 0 ? 0 : strnlen(_String, _MaxCount);

    }







 char*  _strnset(

      char*  _Dest,

     int    _Val,

     size_t _Count

    );



 

 errno_t  _strnset_s(

      char*  _String,

     size_t _SizeInBytes,

     int    _Value,

     size_t _MaxCount

    );



 





 char * _strnset ( 

 char * _Destination , 

 int _Value , 

 size_t _Count 

 ) ; 



 

 char  *  strpbrk(

     char const* _Str,

     char const* _Control

    );



 char*  _strrev(

     char* _Str

    );



 

 errno_t  _strset_s(

      char*  _Destination,

     size_t _DestinationSize,

     int    _Value

    );



 





 char * _strset ( 

 char * _Destination , 

 int _Value 

 ) ; 



char*  _strset(

     char* _Dest,

     int   _Value

    );



 

 size_t  strspn(

     char const* _Str,

     char const* _Control

    );



  

 char*  strtok(

     char*       _String,

     char const* _Delimiter

    );



 

 errno_t  _strupr_s(

      char*  _String,

     size_t _Size

    );



 





 char * _strupr ( 

 char * _String 

 ) ; 



 

 errno_t  _strupr_s_l(

      char*     _String,

     size_t    _Size,

     _locale_t _Locale

    );



 





 char * _strupr_l ( 

 char * _String , 

 _locale_t _Locale 

 ) ; 



 

 

 size_t  strxfrm(

       char*       _Destination,

     char const* _Source,

                size_t      _MaxCount

    );



 

 

 size_t  _strxfrm_l(

       char*       _Destination,

     char const* _Source,

                size_t      _MaxCount,

     _locale_t   _Locale

    );



































 











typedef struct

{

    char*  c_str;

    size_t size;

    size_t capacity;



} StrBuilder;









Result StrBuilder_Init(StrBuilder* p, size_t capacity);



Result StrBuilder_Reserve(StrBuilder* p, size_t nelements);



void StrBuilder_Attach(StrBuilder* wstr,

                       char* psz,

                       size_t nBytes);



void StrBuilder_Destroy(StrBuilder* wstr);

void StrBuilder_Swap(StrBuilder* str1, StrBuilder* str2);





void StrBuilder_Clear(StrBuilder* wstr);



Result StrBuilder_SetN(StrBuilder* p,

                       const char* source,

                       size_t nelements);



Result StrBuilder_Set(StrBuilder* p,

                      const char* source);



Result StrBuilder_AppendN(StrBuilder* p,

                          const char* source,

                          size_t nelements);



Result StrBuilder_Append(StrBuilder* p,

                         const char* source);



char* StrBuilder_Release(StrBuilder* p);



Result StrBuilder_AppendInt(StrBuilder * p, int i);





Result StrBuilder_AppendWChar(StrBuilder * p, wchar_t wch);

Result StrBuilder_AppendW(StrBuilder * p, const wchar_t* psz);

Result StrBuilder_AppendChar(StrBuilder * p, char wch);

void StrBuilder_Trim(StrBuilder* p);

Result StrBuilder_AppendUpper(StrBuilder *p, const char* s);























































































































































































































































































































































































































































































































































































































 







typedef void* _HFILE; 



















































typedef int ( * _CRT_REPORT_HOOK )(int, char*,    int*);

typedef int ( * _CRT_REPORT_HOOKW)(int, wchar_t*, int*);











typedef int ( * _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);













































































































typedef void ( * _CRT_DUMP_CLIENT)(void*, size_t);









struct _CrtMemBlockHeader;



typedef struct _CrtMemState

{

    struct _CrtMemBlockHeader* pBlockHeader;

    size_t lCounts[5 ];

    size_t lSizes[5 ];

    size_t lHighWaterCount;

    size_t lTotalCount;

} _CrtMemState;











































    



         int*   __p__crtDbgFlag(void);

         long*  __p__crtBreakAlloc(void);



        

        



         _CRT_ALLOC_HOOK  _CrtGetAllocHook(void);



         _CRT_ALLOC_HOOK  _CrtSetAllocHook(

             _CRT_ALLOC_HOOK _PfnNewHook

            );



         _CRT_DUMP_CLIENT  _CrtGetDumpClient(void);



         _CRT_DUMP_CLIENT  _CrtSetDumpClient(

             _CRT_DUMP_CLIENT _PFnNewDump

            );



    



     int  _CrtCheckMemory(void);



    typedef void ( * _CrtDoForAllClientObjectsCallback)(void*, void*);



     void  _CrtDoForAllClientObjects(

         _CrtDoForAllClientObjectsCallback _Callback,

         void*                             _Context

        );



     int  _CrtDumpMemoryLeaks(void);



     int  _CrtIsMemoryBlock(

         void const*  _Block,

         unsigned int _Size,

         long*        _RequestNumber,

         char**       _FileName,

         int*         _LineNumber

        );



     

     int  _CrtIsValidHeapPointer(

         void const* _Pointer

        );



     

     int  _CrtIsValidPointer(

         void const*  _Pointer,

         unsigned int _Size,

         int          _ReadWrite

        );



     void  _CrtMemCheckpoint(

         _CrtMemState* _State

        );



     int  _CrtMemDifference(

         _CrtMemState*       _State,

         _CrtMemState const* _OldState,

         _CrtMemState const* _NewState

        );



     void  _CrtMemDumpAllObjectsSince(

         _CrtMemState const* _State

        );



     void  _CrtMemDumpStatistics(

         _CrtMemState const* _State

        );



     

     int  _CrtReportBlockType(

         void const* _Block

        );



     long  _CrtSetBreakAlloc(

         long _NewValue

        );



     int  _CrtSetDbgFlag(

         int _NewFlag

        );



























































































    













































































     void  _aligned_free_dbg(

          void* _Block

        );



       

      void*  _aligned_malloc_dbg(

         size_t      _Size,

         size_t      _Alignment,

         char const* _FileName,

         int         _LineNumber

        );



     size_t  _aligned_msize_dbg(

         void*  _Block,

         size_t _Alignment,

         size_t _Offset

        );



       

      void*  _aligned_offset_malloc_dbg(

         size_t      _Size,

         size_t      _Alignment,

         size_t      _Offset,

         char const* _FileName,

         int         _LineNumber

        );



         

      void*  _aligned_offset_realloc_dbg(

          void*       _Block,

         size_t      _Size,

         size_t      _Alignment,

         size_t      _Offset,

         char const* _FileName,

         int         _LineNumber

        );



         

      void*  _aligned_offset_recalloc_dbg(

          void*       _Block,

         size_t      _Count,

         size_t      _Size,

         size_t      _Alignment,

         size_t      _Offset,

         char const* _FileName,

         int         _LineNumber

        );



         

      void*  _aligned_realloc_dbg(

          void*       _Block,

         size_t      _Size,

         size_t      _Alignment,

         char const* _FileName,

         int         _LineNumber

        );



         

      void*  _aligned_recalloc_dbg(

          void*       _Block,

         size_t      _Count,

         size_t      _Size,

         size_t      _Alignment,

         char const* _FileName,

         int         _LineNumber

        );



       

      void*  _calloc_dbg(

         size_t      _Count,

         size_t      _Size,

         int         _BlockUse,

         char const* _FileName,

         int         _LineNumber

        );



       

      void*  _expand_dbg(

         void*       _Block,

         size_t      _Size,

         int         _BlockUse,

         char const* _FileName,

         int         _LineNumber

        );



     void  _free_dbg(

          void* _Block,

         int   _BlockUse

        );



       

      void*  _malloc_dbg(

         size_t      _Size,

         int         _BlockUse,

         char const* _FileName,

         int         _LineNumber

        );



     size_t  _msize_dbg(

         void* _Block,

         int   _BlockUse

        );



         

      void*  _realloc_dbg(

          void*       _Block,

         size_t      _Size,

         int         _BlockUse,

         char const* _FileName,

         int         _LineNumber

        );



         

      void*  _recalloc_dbg(

          void*       _Block,

         size_t      _Count,

         size_t      _Size,

         int         _BlockUse,

         char const* _FileName,

         int         _LineNumber

        );



     

     

     errno_t  _dupenv_s_dbg(

           char** _PBuffer,

         size_t*     _PBufferSizeInBytes,

         char const* _VarName,

         int          _BlockType,

         char const* _FileName,

         int          _LineNumber

        );



     

      

      char*  _fullpath_dbg(

          char*       _FullPath,

         char const* _Path,

         size_t      _SizeInBytes,

         int         _BlockType,

         char const* _FileName,

         int         _LineNumber

        );



     

      

      char*  _getcwd_dbg(

          char*       _DstBuf,

         int         _SizeInBytes,

         int         _BlockType,

         char const* _FileName,

         int         _LineNumber

        );





     

      

      char*  _getdcwd_dbg(

         int         _Drive,

          char*       _DstBuf,

         int         _SizeInBytes,

         int         _BlockType,

         char const* _FileName,

         int         _LineNumber

        );



      

      char*  _strdup_dbg(

         char const* _String,

         int         _BlockUse,

         char const* _FileName,

         int         _LineNumber

        );



      

      char*  _tempnam_dbg(

         char const* _DirName,

         char const* _FilePrefix,

         int         _BlockType,

         char const* _FileName,

         int         _LineNumber

        );



     

      

      wchar_t*  _wcsdup_dbg(

         wchar_t const* _String,

         int            _BlockUse,

         char const*    _FileName,

         int            _LineNumber

        );



     

     

     errno_t  _wdupenv_s_dbg(

           wchar_t** _PBuffer,

         size_t*         _PBufferSizeInWords,

         wchar_t const* _VarName,

         int             _BlockType,

         char const*    _FileName,

         int             _LineNumber

        );



     

      

      wchar_t*  _wfullpath_dbg(

          wchar_t*       _FullPath,

         wchar_t const* _Path,

         size_t         _SizeInWords,

         int            _BlockType,

         char const*    _FileName,

         int            _LineNumber

        );

    

     

      

      wchar_t*  _wgetcwd_dbg(

          wchar_t*    _DstBuf,

         int         _SizeInWords,

         int         _BlockType,

         char const* _FileName,

         int         _LineNumber

        );



     

      

      wchar_t*  _wgetdcwd_dbg(

         int         _Drive,

          wchar_t*    _DstBuf,

         int         _SizeInWords,

         int         _BlockType,

         char const* _FileName,

         int         _LineNumber

        );



      

      wchar_t*  _wtempnam_dbg(

         wchar_t const* _DirName,

         wchar_t const* _FilePrefix,

         int            _BlockType,

         char const*    _FileName,

         int            _LineNumber

        );



    

    



    













































     int  _CrtDbgReport(

         int         _ReportType,

         char const* _FileName,

         int         _Linenumber,

         char const* _ModuleName,

         char const* _Format,

        ...);



     int  _CrtDbgReportW(

         int            _ReportType,

         wchar_t const* _FileName,

         int            _LineNumber,

         wchar_t const* _ModuleName,

         wchar_t const* _Format,

        ...);





     int  _VCrtDbgReportA(

         int         _ReportType,

         void*       _ReturnAddress,

         char const* _FileName,

         int         _LineNumber,

         char const* _ModuleName,

         char const* _Format,

                   va_list     _ArgList

        );



     int  _VCrtDbgReportW(

         int            _ReportType,

         void*          _ReturnAddress,

         wchar_t const* _FileName,

         int            _LineNumber,

         wchar_t const* _ModuleName,

         wchar_t const* _Format,

                   va_list        _ArgList

        );



     size_t  _CrtSetDebugFillThreshold(

         size_t _NewDebugFillThreshold

        );



     size_t  _CrtGetDebugFillThreshold(void);



     _HFILE  _CrtSetReportFile(

         int    _ReportType,

         _HFILE _ReportFile

        );



     int  _CrtSetReportMode(

         int _ReportType,

         int _ReportMode

        );



    



        extern long _crtAssertBusy;



         _CRT_REPORT_HOOK  _CrtGetReportHook(void);



        

        

        

         _CRT_REPORT_HOOK  _CrtSetReportHook(

             _CRT_REPORT_HOOK _PFnNewHook

            );



         int  _CrtSetReportHook2(

             int              _Mode,

             _CRT_REPORT_HOOK _PFnNewHook

            );



         int  _CrtSetReportHookW2(

             int               _Mode,

             _CRT_REPORT_HOOKW _PFnNewHook

            );



    

































































    



    

    

    

        

    



    

        

    



    

        

    



    



    



    

    



    

    



    

    



    

    

















    

























































 

















typedef char * String;





Result String_Init(String* pString, const char* source);

void   String_Destroy(String* pString);

void   String_Reset(String* pString);

void   String_Attach(String* pString, char* psz);

void   String_Swap(String* pA, String* pB);

_Bool String_IsEmpty(const char* psz);

Result String_Set(String *pS1, const char* psz1);

















typedef struct

{

    

    String NameOrFullPath;

    String FullDir2;



    

    String text;

    size_t text_length;



    size_t position;

    wchar_t currentChar;



    int currentLine;

    int currentCol;



} SStream;



void GetFullPath(const char* fileName, String* out);

void GetFullDir(const char* fileName, String* out);

_Bool IsFullPath(const char * path);

_Bool IsInPath(const char * filePath, const char* path);

_Bool FileExists(const char* fullPath);



Result SStream_Init(SStream* pfStream,

                    const char* name,

                    const char* psz);



Result SStream_InitFile(SStream* pfStream,

                        const char* fileName);



void SStream_Destroy(SStream* pfStream);



wchar_t SStream_LookAhead(SStream* pStream);



void SStream_Next(SStream* pStream);









typedef enum

{

    TK_NONE,

    TK_EOF,

    TK_EndMark,

    TK_LINE_COMMENT,

    TK_COMMENT,

    TK_string_literal,

    TK_identifier,

    TK_SPACES,

    TK_DECIMAL_INTEGER,

    TK_HEX_INTEGER,

    TK_FLOAT_NUMBER,

    TK_MACROPLACEHOLDER,

    TK_BREAKLINE,

    CHAR1, 

    CHARACTER_TABULATION,

    TK_PREPROCESSOR,

    TK_ERROR, 





    

    TK_EXCLAMATION_MARK,

    TK_QUOTATION_MARK,

    TK_NUMBER_SIGN,



    TK_DOLLAR_SIGN,

    TK_PERCENT_SIGN,

    TK_AMPERSAND,

    TK_APOSTROPHE,

    TK_LEFT_PARENTHESIS,

    TK_RIGHT_PARENTHESIS,

    TK_ASTERISK,

    TK_PLUS_SIGN,

    TK_COMMA,

    TK_HYPHEN_MINUS,

    TK_HYPHEN_MINUS_NEG,

    TK_FULL_STOP,

    TK_SOLIDUS,



    TK_COLON,

    TK_SEMICOLON,

    TK_LESS_THAN_SIGN,

    TK_EQUALS_SIGN,

    TK_GREATER_THAN_SIGN,

    TK_QUESTION_MARK,

    TK_COMMERCIAL_AT,



    TK_LEFT_SQUARE_BRACKET,

    REVERSE_SOLIDUS,

    TK_RIGHT_SQUARE_BRACKET,

    TK_CIRCUMFLEX_ACCENT,

    TK_LOW_LINE,

    TK_GRAVE_ACCENT,



    TK_LEFT_CURLY_BRACKET,

    TK_VERTICAL_LINE,

    TK_RIGHT_CURLY_BRACKET,

    TK_TILDE, 



    

    TK_ARROW,

    TK_PLUSPLUS,

    TK_MINUSMINUS,

    TK_LESSLESS,

    TK_GREATERGREATER,

    TK_LESSEQUAL,

    TK_GREATEREQUAL,

    TK_EQUALEQUAL,

    TK_NOTEQUAL,

    TK_ANDAND,

    TK_OROR,

    TK_MULTIEQUAL,

    TK_DIVEQUAL,

    TK_PERCENT_EQUAL,

    TK_PLUSEQUAL,

    TK_MINUS_EQUAL,

    TK_ANDEQUAL,

    TK_CARETEQUAL,

    TK_OREQUAL,

    TK_NUMBERNUMBER,

    TK_LESSCOLON,

    TK_COLONGREATER,

    TK_LESSPERCENT,

    TK_PERCENTGREATER,

    TK_PERCENTCOLON,

    TK_DOTDOTDOT,

    TK_GREATERGREATEREQUAL,

    TK_LESSLESSEQUAL,

    TK_PERCENTCOLONPERCENTCOLON,



    TK_char_literal,



    TK_auto,

    TK_BREAK,

    TK_case,

    TK_char,

    TK_const,

    TK_CONTINUE,

    TK_DEFAULT,

    TK_DO,

    TK_double,

    TK_ELSE,

    TK_enum,

    TK_extern,

    TK_float,

    TK_FOR,

    TK_GOTO,

    TK_IF,

    TK_int,

    TK_long,

    TK_register,

    TK_RETURN,

    TK_short,

    TK_signed,

    TK_SIZEOF,

    TK_static,

    TK_struct,

    TK_SWITCH,

    TK_typedef,

    TK_union,

    TK_unsigned,

    TK_void,

    TK_volatile,

    TK_WHILE,

    TK__Thread_local,

    TK__Bool,

    TK__Complex,

    TK__Atomic,

    TK_restrict,

    TK__Static_assert,

    TK_inline,

    TK__Noreturn,

    TK__Alignas,

    TK__Generic,

    TK__Imaginary,

    TK__Alignof,



    

    TK__Asm, 

} Tokens;



 _Bool IsNumber(Tokens token)

{

    return token == TK_DECIMAL_INTEGER ||

           token == TK_FLOAT_NUMBER ||

           token == TK_HEX_INTEGER ||

           token == TK_char_literal;

}



typedef struct

{

    StrBuilder lexeme;

    Tokens token;

} ScannerItem;





const char* TokenToString(Tokens tk);



void ScannerItem_Init(ScannerItem* scannerItem);

void ScannerItem_Reset(ScannerItem* scannerItem);

void ScannerItem_Swap(ScannerItem* scannerItem, ScannerItem* other);

void ScannerItem_Destroy(ScannerItem* scannerItem);

void ScannerItem_Copy(ScannerItem* scannerItem, ScannerItem* other);



typedef struct ScannerT

{

    SStream stream;

    ScannerItem currentItem;



    

    _Bool bLineStart;

    _Bool bMacroExpanded;

    int FileIndex;

} BasicScanner;



Result      BasicScanner_Create(BasicScanner** pp, const char* name, const char* text);

const char* BasicScanner_Lexeme(BasicScanner* scanner);

_Bool BasicScanner_IsLexeme(BasicScanner* scanner, const char* psz);

void        BasicScanner_Next(BasicScanner* scanner);

void        BasicScanner_NextNoSpaces(BasicScanner* scanner);

Result      BasicScanner_InitFile(BasicScanner* pScanner, const char* fileName);

Result      BasicScanner_CreateFile(const char* fileName, BasicScanner** pp);

void        BasicScanner_Delete(BasicScanner* pScanner);



Result BasicScanner_Init(BasicScanner* pScanner,

                         const char* name,

                         const char* text);

void BasicScanner_Destroy(BasicScanner* pScanner);



typedef struct

{

    ScannerItem* strings;

    size_t size;

    size_t capacity;

} ScannerItemStack;





Result ScannerItemStack_Init(ScannerItemStack* st);

void   ScannerItemStack_Destroy(ScannerItemStack* st);

Result ScannerItemStack_PushMove(ScannerItemStack* st, ScannerItem* item);

void   ScannerItemStack_PopMove(ScannerItemStack* st, ScannerItem* item);

void   ScannerItemStack_Pop(ScannerItemStack* st);

Result ScannerItemStack_PopPushTo(ScannerItemStack* st, ScannerItemStack* other);

_Bool ScannerItemStack_IsEmpty(ScannerItemStack* st);

Tokens ScannerItemStack_TopToken(ScannerItemStack* st);

void   ScannerItemStack_Print(ScannerItemStack* st);

void ScannerItemStack_Swap(ScannerItemStack* p1, ScannerItemStack* p2);

























































































































































































































































































































































































































































































typedef signed char        int8_t;

typedef short              int16_t;

typedef int                int32_t;

typedef long long          int64_t;

typedef unsigned char      uint8_t;

typedef unsigned short     uint16_t;

typedef unsigned int       uint32_t;

typedef unsigned long long uint64_t;



typedef signed char        int_least8_t;

typedef short              int_least16_t;

typedef int                int_least32_t;

typedef long long          int_least64_t;

typedef unsigned char      uint_least8_t;

typedef unsigned short     uint_least16_t;

typedef unsigned int       uint_least32_t;

typedef unsigned long long uint_least64_t;



typedef signed char        int_fast8_t;

typedef int                int_fast16_t;

typedef int                int_fast32_t;

typedef long long          int_fast64_t;

typedef unsigned char      uint_fast8_t;

typedef unsigned int       uint_fast16_t;

typedef unsigned int       uint_fast32_t;

typedef unsigned long long uint_fast64_t;



typedef long long          intmax_t;

typedef unsigned long long uintmax_t;





























































































    

    

    





















































































 

















typedef struct

{

    intmax_t quot;

    intmax_t rem;

} _Lldiv_t;



typedef _Lldiv_t imaxdiv_t;

















 

 intmax_t  imaxabs(

     intmax_t _Number

    );



 

 imaxdiv_t  imaxdiv(

     intmax_t _Numerator,

     intmax_t _Denominator

    );



 intmax_t  strtoimax(

     char const* _String,

      char**      _EndPtr,

     int         _Radix

    );



 intmax_t  _strtoimax_l(

     char const* _String,

      char**      _EndPtr,

     int         _Radix,

     _locale_t   _Locale

    );



 uintmax_t  strtoumax(

     char const* _String,

      char**      _EndPtr,

     int         _Radix

    );



 uintmax_t  _strtoumax_l(

     char const* _String,

      char**      _EndPtr,

     int         _Radix,

     _locale_t   _Locale

    );



 intmax_t  wcstoimax(

     wchar_t const* _String,

      wchar_t**      _EndPtr,

     int            _Radix

    );



 intmax_t  _wcstoimax_l(

     wchar_t const* _String,

      wchar_t**      _EndPtr,

     int            _Radix,

     _locale_t      _Locale

    );



 uintmax_t  wcstoumax(

     wchar_t const* _String,

      wchar_t**      _EndPtr,

     int            _Radix

    );



 uintmax_t  _wcstoumax_l(

     wchar_t const* _String,

      wchar_t**      _EndPtr,

     int            _Radix,

     _locale_t      _Locale

    );

















































    





































    





































    





































    





































    





































    



















































    





































    





































    





































    





































    









 













typedef struct

{

    String key;

    void *data;

    uint32_t hash;

} BucketItem;





typedef struct

{

    BucketItem** data;

    size_t size;

    size_t capacity;



} Bucket;





typedef struct

{

    Bucket** data;

    size_t size;

} Buckets;





typedef struct

{

    Buckets buckets;

    int Size;

} Map;







Result Map_Init(Map* map, size_t nBuckets);



void Map_Swap(Map* map, Map* map2);



void Map_Destroy(Map *map, void(*pfDestroyData)(void*));



void Map_Delete(Map *map, void(*pfDestroyData)(void*));

Result Map_Create(Map **map, size_t nBuckets);



Result Map_Set(Map *map, const char*key, void *data);

Result Map_SetMoveKey(Map* map, String* key, void* data);



Result Map_Find(Map* map, const char* key, void** pp);

void* Map_Find2(Map* map, const char* key);

Result Map_DeleteItem(Map *map, const char* key, void(*pfDestroyData)(void*));

Result Map_DeleteItemOpt(Map* map, const char* key, void(*pfDestroyData)(void*));



void Map_Print(Map *map);





typedef Map StrSet;



Result StrSet_Init(StrSet* p, size_t nBuckets);

void StrSet_Destroy(StrSet* p);

void StrSet_SetKey(StrSet* p, const char* str);

void StrSet_DeleteKey(StrSet* p, const char* str);

_Bool StrSet_HasKey(StrSet* p, const char* key);





typedef Map StrMap;

Result StrMap_Init(StrMap* StrMap, size_t nBuckets);



void StrMap_Destroy(StrMap *StrMap);

Result StrMap_Set(StrMap *StrMap, const char*key, const char *value);

const char* StrMap_Find2(StrMap* StrMap, const char* key);

Result StrMap_DeleteItem(StrMap *StrMap, const char* key);











typedef struct

{

  Buckets buckets;

  int Size;

} MultiMap;







Result MultiMap_Init(MultiMap* map, size_t nBuckets);

void MultiMap_Destroy(MultiMap *map, void(*pfDestroyData)(void*));





Result MultiMap_Add(MultiMap *map, const char*key, void *data);









Bucket* MultiMap_FindBucket(MultiMap* map, const char* key);

void MultiMap_Swap(MultiMap* map, MultiMap* map2);









typedef struct

{

    String Name;

    StrArray Args;

    StrBuilder Content;

    int FileIndex;

} TMacro;





TMacro* TMacro_Create();

void TMacro_Delete(TMacro*);



typedef Map TMacroMap;





void TMacroMap_Init(TMacroMap* p);

void TMacroMap_Destroy(TMacroMap* p);

Result TMacroMap_Set(TMacroMap *map, const char*key, TMacro *data);

TMacro* TMacroMap_Find(TMacroMap* map, const char* key);

Result TMacroMap_DeleteItem(TMacroMap *map, const char* key);

void TMacroMap_Swap(TMacroMap *a, TMacroMap *b);



typedef struct

{

    String FullPath;

    int FileIndex;

    _Bool PragmaOnce;

	int FileLevel;

} TFile;





typedef Map TFileMap;



void TFileMap_Destroy(TFileMap* p);

Result TFileMap_Set(TFileMap *map, const char*key, TFile *data);

TFile* TFileMap_Find(TFileMap* map, const char* key);

Result TFileMap_DeleteItem(TFileMap *map, const char* key);

void TFile_DeleteVoid(void* p);



typedef struct

{

	TFile** pItems;

	size_t size;

	size_t capacity;

} TFileArray;



inline void TFileArray_Push ( TFileArray * p , TFile * pItem ) { Array_Push ( ( Array * ) p , pItem ) ; } inline void TFileArray_Destroy ( TFileArray * p ) { Array_Destroy ( ( Array * ) p , TFile_DeleteVoid ) ; } inline TFileArray * TFileArray_Create ( ) { TFileArray * p = ( TFileArray * ) malloc ( sizeof * p ) ; if ( p ) { Array_Init ( ( Array * ) p ) ; } return p ; } inline Result TFileArray_Reserve ( TFileArray * p , size_t n ) { return Array_Reserve ( ( Array * ) p , n ) ; } inline void TFileArray_Delete ( TFileArray * p ) { if ( p ) { Array_Destroy ( ( Array * ) p , TFile_DeleteVoid ) ; free ( p ) ; } } 



typedef struct

{

    

    Array stack;



    

    TMacroMap Defines;



    

    ArrayInt StackIfDef;



    

    TFileMap FilesIncluded;



    

    StrArray IncludeDir;



    

    _Bool bExpressionMode;



    

    StrBuilder DebugString;



    

    StrBuilder ErrorString;



    

    _Bool bError;



    

    _Bool bPrintIncludes;



    

    _Bool bIncludeSpaces;



    

    _Bool bHasLookAhead;



    

    ScannerItem LookAhead;



} Scanner;



void Scanner_SetError(Scanner* pScanner, const char* message);



const char* Scanner_GetStreamName(Scanner* pScanner);

Result Scanner_InitString(Scanner* pScanner,

                          const char* name,

                          const char* text,

                          _Bool bExpressionMode);



const char* Scanner_TokenString(Scanner* pScanner);

Tokens Scanner_Token(Scanner* pScanner);

const char* Scanner_Lexeme(Scanner* pScanner);



Result Scanner_Init(Scanner* pScanner);



typedef enum

{

    FileIncludeTypeQuoted,

    FileIncludeTypeIncludes,

    FileIncludeTypeFullPath,

} FileIncludeType;



void Scanner_IncludeFile(Scanner* pScanner,

                         const char* fileName,

                         FileIncludeType fileIncludeType);



void Scanner_Destroy(Scanner* pScanner);

int Scanner_GetCurrentLine(Scanner * pScanner);

int Scanner_GetFileIndex(Scanner * pScanner);



Tokens Scanner_Token(Scanner * pScanner);

const char * Scanner_Lexeme(Scanner * pScanner);





int Scanner_Line(Scanner* scanner);

int Scanner_Col(Scanner* scanner);

void Scanner_Next(Scanner* pScanner);

void Scanner_Skip(Scanner* pScanner);



int EvalExpression(const char* s, Scanner* pScanner);

void Scanner_PrintDebug(Scanner* pScanner);

void Scanner_GetError(Scanner* pScanner, StrBuilder* str);





void PrintPreprocessedToFile(const char* fileIn,

  const char* configFileName,

  const char* fileNameOut);



void Scanner_GetScannerItemCopy(Scanner* pScanner,

                                ScannerItem* scannerItem);



ScannerItem* Scanner_GetLookAhead(Scanner* pScanner);

































typedef enum

{

  TypeNull,

  TDeclaration_ID,

  TStaticAssertDeclaration_ID,



  TSingleTypeSpecifier_ID,

  TEnumSpecifier_ID,

  TStructUnionSpecifier_ID,



  TStructDeclaration_ID,



  TCompoundStatement_ID,

  TExpressionStatement_ID,

  TSwitchStatement_ID,

  TLabeledStatement_ID,

  TForStatement_ID,

  TJumpStatement_ID,

  TAsmStatement_ID,

  TWhileStatement_ID,

  TDoStatement_ID,

  TIfStatement_ID,

  TReturnStatement_ID,

  TInitializerListType_ID,



  TPrimaryExpression_ID,

  TUnaryExpressionOperator_ID,

  TCastExpressionType_ID,

  TPrimaryExpressionValue_ID,

  TPostfixExpressionCore_ID,

  TBinaryExpression_ID,

  TTernaryExpression_ID

} Type;



















typedef struct

{

  Type type;

} TTypePointer;



typedef TTypePointer TExpression2;



typedef struct

{

  TTypePointer Type;

  TExpression2* pConstantExpression;

} TStaticAssertDeclaration;



inline TStaticAssertDeclaration * TStaticAssertDeclaration_Create ( ) { TStaticAssertDeclaration * p = ( TStaticAssertDeclaration * ) malloc ( sizeof * p ) ; if ( p ) { TStaticAssertDeclaration temp_Moved = { { TStaticAssertDeclaration_ID } , ( ( void * ) 0 ) } ; * p = && temp_Moved ; } return p ; } void TStaticAssertDeclaration_Destroy ( TStaticAssertDeclaration * p ) ; inline void TStaticAssertDeclaration_Delete ( TStaticAssertDeclaration * p ) { if ( p ) { TStaticAssertDeclaration_Destroy ( p ) ; free ( p ) ; } } inline void TStaticAssertDeclaration_DeleteVoid ( void * p ) { TStaticAssertDeclaration_Delete ( ( TStaticAssertDeclaration * ) p ) ; } 





typedef TTypePointer TStatement;

typedef TTypePointer TBlockItem;



typedef TTypePointer TBlockItem ; void TBlockItem_Destroy ( TBlockItem * p ) ; inline void TBlockItem_Delete ( TBlockItem * p ) { if ( p ) { TBlockItem_Destroy ( p ) ; free ( p ) ; } } inline void TBlockItem_DeleteVoid ( void * p ) { TBlockItem_Delete ( ( TBlockItem * ) p ) ; } 

inline TStatement * TBlockItem_As_TStatement ( TBlockItem * p ) { return p ; } inline TBlockItem * TStatement_As_TBlockItem ( TStatement * p ) { return p ; } 



typedef TTypePointer TAnyDeclaration;

inline TAnyDeclaration * TBlockItem_As_TAnyDeclaration ( TBlockItem * p ) { return p ; } inline TBlockItem * TAnyDeclaration_As_TBlockItem ( TAnyDeclaration * p ) { return p ; } 

typedef TTypePointer TAnyDeclaration ; void TAnyDeclaration_Destroy ( TAnyDeclaration * p ) ; inline void TAnyDeclaration_Delete ( TAnyDeclaration * p ) { if ( p ) { TAnyDeclaration_Destroy ( p ) ; free ( p ) ; } } inline void TAnyDeclaration_DeleteVoid ( void * p ) { TAnyDeclaration_Delete ( ( TAnyDeclaration * ) p ) ; } 





typedef struct

{

  TBlockItem** pItems;

  size_t size;

  size_t capacity;

} TBlockItemList;





inline void TBlockItemList_Push ( TBlockItemList * p , TBlockItem * pItem ) { Array_Push ( ( Array * ) p , pItem ) ; } inline void TBlockItemList_Destroy ( TBlockItemList * p ) { Array_Destroy ( ( Array * ) p , TBlockItem_DeleteVoid ) ; } inline TBlockItemList * TBlockItemList_Create ( ) { TBlockItemList * p = ( TBlockItemList * ) malloc ( sizeof * p ) ; if ( p ) { Array_Init ( ( Array * ) p ) ; } return p ; } inline Result TBlockItemList_Reserve ( TBlockItemList * p , size_t n ) { return Array_Reserve ( ( Array * ) p , n ) ; } inline void TBlockItemList_Delete ( TBlockItemList * p ) { if ( p ) { Array_Destroy ( ( Array * ) p , TBlockItem_DeleteVoid ) ; free ( p ) ; } } 





typedef struct

{

  TTypePointer Type;

  TBlockItemList BlockItemList;

} TCompoundStatement;





inline TCompoundStatement * TCompoundStatement_Create ( ) { TCompoundStatement * p = ( TCompoundStatement * ) malloc ( sizeof * p ) ; if ( p ) { TCompoundStatement temp_Moved = { { TCompoundStatement_ID } , { ( ( void * ) 0 ) , 0 , 0 } } ; * p = && temp_Moved ; } return p ; } void TCompoundStatement_Destroy ( TCompoundStatement * p ) ; inline void TCompoundStatement_Delete ( TCompoundStatement * p ) { if ( p ) { TCompoundStatement_Destroy ( p ) ; free ( p ) ; } } inline void TCompoundStatement_DeleteVoid ( void * p ) { TCompoundStatement_Delete ( ( TCompoundStatement * ) p ) ; } 











typedef struct

{

  TTypePointer Type;

  Tokens token;

  String lexeme;

  TExpression2* ^ pExpressionOpt;

} TPrimaryExpressionValue;



inline TPrimaryExpressionValue * TPrimaryExpressionValue_Create ( ) { TPrimaryExpressionValue * p = ( TPrimaryExpressionValue * ) malloc ( sizeof * p ) ; if ( p ) { TPrimaryExpressionValue temp_Moved = { { TPrimaryExpressionValue_ID } , TK_NONE , ( ( void * ) 0 ) , ( ( void * ) 0 ) } ; * p = && temp_Moved ; } return p ; } void TPrimaryExpressionValue_Destroy ( TPrimaryExpressionValue * p ) ; inline void TPrimaryExpressionValue_Delete ( TPrimaryExpressionValue * p ) { if ( p ) { TPrimaryExpressionValue_Destroy ( p ) ; free ( p ) ; } } inline void TPrimaryExpressionValue_DeleteVoid ( void * p ) { TPrimaryExpressionValue_Delete ( ( TPrimaryExpressionValue * ) p ) ; } 





  

typedef struct TPostfixExpressionCoreTag

{

  TTypePointer Type;

  Tokens token;

  String lexeme;

  TExpression2* ^ pExpressionLeft;

  TExpression2* ^ pExpressionArray;

  

  

  

  

  struct TPostfixExpressionCoreTag* ^ pNext;

  struct TInitializerList_ * ^ pInitializerList;

  String Identifier;

  

} TPostfixExpressionCore;



inline TPostfixExpressionCore * TPostfixExpressionCore_Create ( ) { TPostfixExpressionCore * p = ( TPostfixExpressionCore * ) malloc ( sizeof * p ) ; if ( p ) { TPostfixExpressionCore temp_Moved = { { TPostfixExpressionCore_ID } , TK_NONE , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) } ; * p = && temp_Moved ; } return p ; } void TPostfixExpressionCore_Destroy ( TPostfixExpressionCore * p ) ; inline void TPostfixExpressionCore_Delete ( TPostfixExpressionCore * p ) { if ( p ) { TPostfixExpressionCore_Destroy ( p ) ; free ( p ) ; } } inline void TPostfixExpressionCore_DeleteVoid ( void * p ) { TPostfixExpressionCore_Delete ( ( TPostfixExpressionCore * ) p ) ; } 





typedef struct

{

  TTypePointer Type;

  Tokens token;

  TExpression2* ^ pExpressionLeft;

  TExpression2* ^ pExpressionRight;

} TBinaryExpression;



inline TBinaryExpression * TBinaryExpression_Create ( ) { TBinaryExpression * p = ( TBinaryExpression * ) malloc ( sizeof * p ) ; if ( p ) { TBinaryExpression temp_Moved = { { TBinaryExpression_ID } , TK_NONE , ( ( void * ) 0 ) , ( ( void * ) 0 ) } ; * p = && temp_Moved ; } return p ; } void TBinaryExpression_Destroy ( TBinaryExpression * p ) ; inline void TBinaryExpression_Delete ( TBinaryExpression * p ) { if ( p ) { TBinaryExpression_Destroy ( p ) ; free ( p ) ; } } inline void TBinaryExpression_DeleteVoid ( void * p ) { TBinaryExpression_Delete ( ( TBinaryExpression * ) p ) ; } 



typedef struct

{

  TTypePointer Type;

  Tokens token;

  TExpression2* ^ pExpressionLeft;

  TExpression2* ^ pExpressionMiddle;

  TExpression2* ^ pExpressionRight;

} TTernaryExpression;



inline TTernaryExpression * TTernaryExpression_Create ( ) { TTernaryExpression * p = ( TTernaryExpression * ) malloc ( sizeof * p ) ; if ( p ) { TTernaryExpression temp_Moved = { { TTernaryExpression_ID } , TK_NONE , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) } ; * p = && temp_Moved ; } return p ; } void TTernaryExpression_Destroy ( TTernaryExpression * p ) ; inline void TTernaryExpression_Delete ( TTernaryExpression * p ) { if ( p ) { TTernaryExpression_Destroy ( p ) ; free ( p ) ; } } inline void TTernaryExpression_DeleteVoid ( void * p ) { TTernaryExpression_Delete ( ( TTernaryExpression * ) p ) ; } 







typedef TTypePointer TExpression2 ; void TExpression2_Destroy ( TExpression2 * p ) ; inline void TExpression2_Delete ( TExpression2 * p ) { if ( p ) { TExpression2_Destroy ( p ) ; free ( p ) ; } } inline void TExpression2_DeleteVoid ( void * p ) { TExpression2_Delete ( ( TExpression2 * ) p ) ; } 



typedef struct

{

	_Bool bIsConst;

	_Bool bIsRestrict;

	_Bool bIsVolatile;

	_Bool bIsAtomic;

	

	

	_Bool bIsOpt;

	_Bool bIsOwner;

	



} TTypeQualifier;





















typedef struct

{

  TTypePointer Type;  

  TExpression2 * ^ pExpression;

} TExpressionStatement;



inline TExpressionStatement * TExpressionStatement_Create ( ) { TExpressionStatement * p = ( TExpressionStatement * ) malloc ( sizeof * p ) ; if ( p ) { TExpressionStatement temp_Moved = { { TExpressionStatement_ID } , ( ( void * ) 0 ) } ; * p = && temp_Moved ; } return p ; } void TExpressionStatement_Destroy ( TExpressionStatement * p ) ; inline void TExpressionStatement_Delete ( TExpressionStatement * p ) { if ( p ) { TExpressionStatement_Destroy ( p ) ; free ( p ) ; } } inline void TExpressionStatement_DeleteVoid ( void * p ) { TExpressionStatement_Delete ( ( TExpressionStatement * ) p ) ; } 



typedef struct

{

  TTypePointer Type;

  Tokens token;

  TExpression2 * ^ pExpression;

} TJumpStatement;





inline TJumpStatement * TJumpStatement_Create ( ) { TJumpStatement * p = ( TJumpStatement * ) malloc ( sizeof * p ) ; if ( p ) { TJumpStatement temp_Moved = { { TJumpStatement_ID } , TK_NONE , ( ( void * ) 0 ) } ; * p = && temp_Moved ; } return p ; } void TJumpStatement_Destroy ( TJumpStatement * p ) ; inline void TJumpStatement_Delete ( TJumpStatement * p ) { if ( p ) { TJumpStatement_Destroy ( p ) ; free ( p ) ; } } inline void TJumpStatement_DeleteVoid ( void * p ) { TJumpStatement_Delete ( ( TJumpStatement * ) p ) ; } 





typedef struct

{

  TTypePointer Type;



} TAsmStatement;





inline TAsmStatement * TAsmStatement_Create ( ) { TAsmStatement * p = ( TAsmStatement * ) malloc ( sizeof * p ) ; if ( p ) { TAsmStatement temp_Moved = { { TAsmStatement_ID } } ; * p = && temp_Moved ; } return p ; } void TAsmStatement_Destroy ( TAsmStatement * p ) ; inline void TAsmStatement_Delete ( TAsmStatement * p ) { if ( p ) { TAsmStatement_Destroy ( p ) ; free ( p ) ; } } inline void TAsmStatement_DeleteVoid ( void * p ) { TAsmStatement_Delete ( ( TAsmStatement * ) p ) ; } 





typedef struct

{

  TTypePointer Type;

  TAnyDeclaration* ^ pInitDeclarationOpt;

  TExpression2* ^ pExpression1;

  TExpression2*^ pExpression2;

  TExpression2* ^ pExpression3;

  TStatement* ^ pStatement;

} TForStatement;





inline TForStatement * TForStatement_Create ( ) { TForStatement * p = ( TForStatement * ) malloc ( sizeof * p ) ; if ( p ) { TForStatement temp_Moved = { { TForStatement_ID } , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) } ; * p = && temp_Moved ; } return p ; } void TForStatement_Destroy ( TForStatement * p ) ; inline void TForStatement_Delete ( TForStatement * p ) { if ( p ) { TForStatement_Destroy ( p ) ; free ( p ) ; } } inline void TForStatement_DeleteVoid ( void * p ) { TForStatement_Delete ( ( TForStatement * ) p ) ; } 



typedef struct

{

  TTypePointer Type;

  TExpression2* ^ pExpression;

  TStatement* ^ pStatement;

} TWhileStatement;





inline TWhileStatement * TWhileStatement_Create ( ) { TWhileStatement * p = ( TWhileStatement * ) malloc ( sizeof * p ) ; if ( p ) { TWhileStatement temp_Moved = { { TWhileStatement_ID } , ( ( void * ) 0 ) , ( ( void * ) 0 ) } ; * p = && temp_Moved ; } return p ; } void TWhileStatement_Destroy ( TWhileStatement * p ) ; inline void TWhileStatement_Delete ( TWhileStatement * p ) { if ( p ) { TWhileStatement_Destroy ( p ) ; free ( p ) ; } } inline void TWhileStatement_DeleteVoid ( void * p ) { TWhileStatement_Delete ( ( TWhileStatement * ) p ) ; } 



typedef struct

{

  TTypePointer Type;

  TExpression2* ^ pExpression;

} TReturnStatement;





inline TReturnStatement * TReturnStatement_Create ( ) { TReturnStatement * p = ( TReturnStatement * ) malloc ( sizeof * p ) ; if ( p ) { TReturnStatement temp_Moved = { { TReturnStatement_ID } , ( ( void * ) 0 ) } ; * p = && temp_Moved ; } return p ; } void TReturnStatement_Destroy ( TReturnStatement * p ) ; inline void TReturnStatement_Delete ( TReturnStatement * p ) { if ( p ) { TReturnStatement_Destroy ( p ) ; free ( p ) ; } } inline void TReturnStatement_DeleteVoid ( void * p ) { TReturnStatement_Delete ( ( TReturnStatement * ) p ) ; } 





typedef struct

{

  TTypePointer Type;

  TExpression2 *  ^ pExpression;

  TStatement*  ^ pStatement;

} TDoStatement;



inline TDoStatement * TDoStatement_Create ( ) { TDoStatement * p = ( TDoStatement * ) malloc ( sizeof * p ) ; if ( p ) { TDoStatement temp_Moved = { { TDoStatement_ID } , ( ( void * ) 0 ) , ( ( void * ) 0 ) } ; * p = && temp_Moved ; } return p ; } void TDoStatement_Destroy ( TDoStatement * p ) ; inline void TDoStatement_Delete ( TDoStatement * p ) { if ( p ) { TDoStatement_Destroy ( p ) ; free ( p ) ; } } inline void TDoStatement_DeleteVoid ( void * p ) { TDoStatement_Delete ( ( TDoStatement * ) p ) ; } 



typedef struct

{

  TTypePointer Type;

  

  TStatement * ^ pStatementOpt;

  TExpression2 * ^ pExpression;

  String Identifier;

  Tokens token;

} TLabeledStatement;





inline TLabeledStatement * TLabeledStatement_Create ( ) { TLabeledStatement * p = ( TLabeledStatement * ) malloc ( sizeof * p ) ; if ( p ) { TLabeledStatement temp_Moved = { { TLabeledStatement_ID } , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , TK_NONE } ; * p = && temp_Moved ; } return p ; } void TLabeledStatement_Destroy ( TLabeledStatement * p ) ; inline void TLabeledStatement_Delete ( TLabeledStatement * p ) { if ( p ) { TLabeledStatement_Destroy ( p ) ; free ( p ) ; } } inline void TLabeledStatement_DeleteVoid ( void * p ) { TLabeledStatement_Delete ( ( TLabeledStatement * ) p ) ; } 





typedef struct

{

  TTypePointer Type;

  TExpression2 *  ^ pConditionExpression;

  TStatement*  ^ pExpression;

} TSwitchStatement;





inline TSwitchStatement * TSwitchStatement_Create ( ) { TSwitchStatement * p = ( TSwitchStatement * ) malloc ( sizeof * p ) ; if ( p ) { TSwitchStatement temp_Moved = { { TSwitchStatement_ID } , ( ( void * ) 0 ) , ( ( void * ) 0 ) } ; * p = && temp_Moved ; } return p ; } void TSwitchStatement_Destroy ( TSwitchStatement * p ) ; inline void TSwitchStatement_Delete ( TSwitchStatement * p ) { if ( p ) { TSwitchStatement_Destroy ( p ) ; free ( p ) ; } } inline void TSwitchStatement_DeleteVoid ( void * p ) { TSwitchStatement_Delete ( ( TSwitchStatement * ) p ) ; } 





typedef struct

{

  TTypePointer Type;

  TExpression2*  ^ pConditionExpression;

  TStatement* ^ pStatement;

  TStatement* ^ pElseStatement;

} TIfStatement;



inline TIfStatement * TIfStatement_Create ( ) { TIfStatement * p = ( TIfStatement * ) malloc ( sizeof * p ) ; if ( p ) { TIfStatement temp_Moved = { { TIfStatement_ID } , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) } ; * p = && temp_Moved ; } return p ; } void TIfStatement_Destroy ( TIfStatement * p ) ; inline void TIfStatement_Delete ( TIfStatement * p ) { if ( p ) { TIfStatement_Destroy ( p ) ; free ( p ) ; } } inline void TIfStatement_DeleteVoid ( void * p ) { TIfStatement_Delete ( ( TIfStatement * ) p ) ; } 







typedef TTypePointer TStatement ; void TStatement_Destroy ( TStatement * p ) ; inline void TStatement_Delete ( TStatement * p ) { if ( p ) { TStatement_Destroy ( p ) ; free ( p ) ; } } inline void TStatement_DeleteVoid ( void * p ) { TStatement_Delete ( ( TStatement * ) p ) ; } 

inline TCompoundStatement * TStatement_As_TCompoundStatement ( TStatement * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TCompoundStatement_ID ) return ( TCompoundStatement * ) p ; return ( ( void * ) 0 ) ; } inline TStatement * TCompoundStatement_As_TStatement ( TCompoundStatement * p ) { return ( TStatement * ) p ; } 

inline TExpressionStatement * TStatement_As_TExpressionStatement ( TStatement * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TExpressionStatement_ID ) return ( TExpressionStatement * ) p ; return ( ( void * ) 0 ) ; } inline TStatement * TExpressionStatement_As_TStatement ( TExpressionStatement * p ) { return ( TStatement * ) p ; } 

inline TLabeledStatement * TStatement_As_TLabeledStatement ( TStatement * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TLabeledStatement_ID ) return ( TLabeledStatement * ) p ; return ( ( void * ) 0 ) ; } inline TStatement * TLabeledStatement_As_TStatement ( TLabeledStatement * p ) { return ( TStatement * ) p ; } 

inline TJumpStatement * TStatement_As_TJumpStatement ( TStatement * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TJumpStatement_ID ) return ( TJumpStatement * ) p ; return ( ( void * ) 0 ) ; } inline TStatement * TJumpStatement_As_TStatement ( TJumpStatement * p ) { return ( TStatement * ) p ; } 

inline TIfStatement * TStatement_As_TIfStatement ( TStatement * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TIfStatement_ID ) return ( TIfStatement * ) p ; return ( ( void * ) 0 ) ; } inline TStatement * TIfStatement_As_TStatement ( TIfStatement * p ) { return ( TStatement * ) p ; } 

inline TDoStatement * TStatement_As_TDoStatement ( TStatement * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TDoStatement_ID ) return ( TDoStatement * ) p ; return ( ( void * ) 0 ) ; } inline TStatement * TDoStatement_As_TStatement ( TDoStatement * p ) { return ( TStatement * ) p ; } 

inline TForStatement * TStatement_As_TForStatement ( TStatement * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TForStatement_ID ) return ( TForStatement * ) p ; return ( ( void * ) 0 ) ; } inline TStatement * TForStatement_As_TStatement ( TForStatement * p ) { return ( TStatement * ) p ; } 

inline TAsmStatement * TStatement_As_TAsmStatement ( TStatement * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TAsmStatement_ID ) return ( TAsmStatement * ) p ; return ( ( void * ) 0 ) ; } inline TStatement * TAsmStatement_As_TStatement ( TAsmStatement * p ) { return ( TStatement * ) p ; } 

inline TReturnStatement * TStatement_As_TReturnStatement ( TStatement * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TReturnStatement_ID ) return ( TReturnStatement * ) p ; return ( ( void * ) 0 ) ; } inline TStatement * TReturnStatement_As_TStatement ( TReturnStatement * p ) { return ( TStatement * ) p ; } 

inline TWhileStatement * TStatement_As_TWhileStatement ( TStatement * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TWhileStatement_ID ) return ( TWhileStatement * ) p ; return ( ( void * ) 0 ) ; } inline TStatement * TWhileStatement_As_TStatement ( TWhileStatement * p ) { return ( TStatement * ) p ; } 

inline TSwitchStatement * TStatement_As_TSwitchStatement ( TStatement * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TSwitchStatement_ID ) return ( TSwitchStatement * ) p ; return ( ( void * ) 0 ) ; } inline TStatement * TSwitchStatement_As_TStatement ( TSwitchStatement * p ) { return ( TStatement * ) p ; } 







typedef struct

{

  TTypeQualifier Qualifier;

} TPointer;



inline TPointer * TPointer_Create ( ) { TPointer * p = ( TPointer * ) malloc ( sizeof * p ) ; if ( p ) { TPointer temp_Moved = { { 0 , 0 , 0 , 0 , 0 , 0 } } ; * p = && temp_Moved ; } return p ; } void TPointer_Destroy ( TPointer * p ) ; inline void TPointer_Delete ( TPointer * p ) { if ( p ) { TPointer_Destroy ( p ) ; free ( p ) ; } } inline void TPointer_DeleteVoid ( void * p ) { TPointer_Delete ( ( TPointer * ) p ) ; } 



typedef struct

{

  TPointer** pItems;

  size_t size;

  size_t capacity;

} TPointerList;



inline void TPointerList_Push ( TPointerList * p , TPointer * pItem ) { Array_Push ( ( Array * ) p , pItem ) ; } inline void TPointerList_Destroy ( TPointerList * p ) { Array_Destroy ( ( Array * ) p , TPointer_DeleteVoid ) ; } inline TPointerList * TPointerList_Create ( ) { TPointerList * p = ( TPointerList * ) malloc ( sizeof * p ) ; if ( p ) { Array_Init ( ( Array * ) p ) ; } return p ; } inline Result TPointerList_Reserve ( TPointerList * p , size_t n ) { return Array_Reserve ( ( Array * ) p , n ) ; } inline void TPointerList_Delete ( TPointerList * p ) { if ( p ) { Array_Destroy ( ( Array * ) p , TPointer_DeleteVoid ) ; free ( p ) ; } } 



typedef struct

{

  _Bool bIsInline;

  _Bool bIsNoReturn;

} TFunctionSpecifier;









typedef struct

{

  _Bool bIsTypedef;

  _Bool bIsExtern;

  _Bool bIsStatic;

  _Bool bIsThread_local;

  _Bool bIsAuto;

  _Bool bIsRegister;

} TStorageSpecifier;







typedef struct

{

  String TypeName;

  

  

} TAlignmentSpecifier;





void TAlignmentSpecifier_Destroy(TAlignmentSpecifier* p);







typedef struct

{

  String Name;  

  TExpression2* ^ pExpression;

} TEnumerator;





inline TEnumerator * TEnumerator_Create ( ) { TEnumerator * p = ( TEnumerator * ) malloc ( sizeof * p ) ; if ( p ) { TEnumerator temp_Moved = { ( ( void * ) 0 ) , ( ( void * ) 0 ) } ; * p = && temp_Moved ; } return p ; } void TEnumerator_Destroy ( TEnumerator * p ) ; inline void TEnumerator_Delete ( TEnumerator * p ) { if ( p ) { TEnumerator_Destroy ( p ) ; free ( p ) ; } } inline void TEnumerator_DeleteVoid ( void * p ) { TEnumerator_Delete ( ( TEnumerator * ) p ) ; } 



typedef struct

{

  TEnumerator** pItems;

  size_t size;

  size_t capacity;

} TEnumeratorList;



inline void TEnumeratorList_Push ( TEnumeratorList * p , TEnumerator * pItem ) { Array_Push ( ( Array * ) p , pItem ) ; } inline void TEnumeratorList_Destroy ( TEnumeratorList * p ) { Array_Destroy ( ( Array * ) p , TEnumerator_DeleteVoid ) ; } inline TEnumeratorList * TEnumeratorList_Create ( ) { TEnumeratorList * p = ( TEnumeratorList * ) malloc ( sizeof * p ) ; if ( p ) { Array_Init ( ( Array * ) p ) ; } return p ; } inline Result TEnumeratorList_Reserve ( TEnumeratorList * p , size_t n ) { return Array_Reserve ( ( Array * ) p , n ) ; } inline void TEnumeratorList_Delete ( TEnumeratorList * p ) { if ( p ) { Array_Destroy ( ( Array * ) p , TEnumerator_DeleteVoid ) ; free ( p ) ; } } 





typedef struct

{

  TTypePointer Type;

  String Name;

  TEnumeratorList EnumeratorList;

} TEnumSpecifier;





inline TEnumSpecifier * TEnumSpecifier_Create ( ) { TEnumSpecifier * p = ( TEnumSpecifier * ) malloc ( sizeof * p ) ; if ( p ) { TEnumSpecifier temp_Moved = { { TEnumSpecifier_ID } , ( ( void * ) 0 ) , { ( ( void * ) 0 ) , 0 , 0 } } ; * p = && temp_Moved ; } return p ; } void TEnumSpecifier_Destroy ( TEnumSpecifier * p ) ; inline void TEnumSpecifier_Delete ( TEnumSpecifier * p ) { if ( p ) { TEnumSpecifier_Destroy ( p ) ; free ( p ) ; } } inline void TEnumSpecifier_DeleteVoid ( void * p ) { TEnumSpecifier_Delete ( ( TEnumSpecifier * ) p ) ; } 



typedef struct

{

  TTypePointer Type;



  _Bool bIsVoid;

  _Bool bIsChar;

  _Bool bIsShort;

  _Bool bIsInt;

  int nLong; 

  _Bool bIsFloat;

  _Bool bIsDouble;

  _Bool bIsSigned;

  _Bool bIsUnsigned;

  _Bool bIsBool;

  _Bool bIsComplex;



  _Bool bIsTypeDef;

  String TypedefName;



  

  _Bool bHasDestructor;

} TSingleTypeSpecifier;





inline TSingleTypeSpecifier * TSingleTypeSpecifier_Create ( ) { TSingleTypeSpecifier * p = ( TSingleTypeSpecifier * ) malloc ( sizeof * p ) ; if ( p ) { TSingleTypeSpecifier temp_Moved = { { TSingleTypeSpecifier_ID } , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , ( ( void * ) 0 ) , 0 } ; * p = && temp_Moved ; } return p ; } void TSingleTypeSpecifier_Destroy ( TSingleTypeSpecifier * p ) ; inline void TSingleTypeSpecifier_Delete ( TSingleTypeSpecifier * p ) { if ( p ) { TSingleTypeSpecifier_Destroy ( p ) ; free ( p ) ; } } inline void TSingleTypeSpecifier_DeleteVoid ( void * p ) { TSingleTypeSpecifier_Delete ( ( TSingleTypeSpecifier * ) p ) ; } 



typedef TTypePointer TTypeSpecifier;



typedef struct

{

  TStorageSpecifier StorageSpecifiers;

  TTypeSpecifier*  ^ pTypeSpecifierOpt;

  TTypeQualifier TypeQualifiers;

  TFunctionSpecifier FunctionSpecifiers;

  TAlignmentSpecifier AlignmentSpecifier;



} TDeclarationSpecifiers;







void TDeclarationSpecifiers_Destroy(TDeclarationSpecifiers* pDeclarationSpecifiers);



struct ParameterList_T;







typedef struct

{

  String Name;

  TExpression2 * ^ pExpression;

} TDesignator;



inline TDesignator * TDesignator_Create ( ) { TDesignator * p = ( TDesignator * ) malloc ( sizeof * p ) ; if ( p ) { TDesignator temp_Moved = { ( ( void * ) 0 ) , ( ( void * ) 0 ) } ; * p = && temp_Moved ; } return p ; } void TDesignator_Destroy ( TDesignator * p ) ; inline void TDesignator_Delete ( TDesignator * p ) { if ( p ) { TDesignator_Destroy ( p ) ; free ( p ) ; } } inline void TDesignator_DeleteVoid ( void * p ) { TDesignator_Delete ( ( TDesignator * ) p ) ; } 



typedef struct

{

  TDesignator** pItems;

  size_t size;

  size_t capacity;

} TDesignatorList;



inline void TDesignatorList_Push ( TDesignatorList * p , TDesignator * pItem ) { Array_Push ( ( Array * ) p , pItem ) ; } inline void TDesignatorList_Destroy ( TDesignatorList * p ) { Array_Destroy ( ( Array * ) p , TDesignator_DeleteVoid ) ; } inline TDesignatorList * TDesignatorList_Create ( ) { TDesignatorList * p = ( TDesignatorList * ) malloc ( sizeof * p ) ; if ( p ) { Array_Init ( ( Array * ) p ) ; } return p ; } inline Result TDesignatorList_Reserve ( TDesignatorList * p , size_t n ) { return Array_Reserve ( ( Array * ) p , n ) ; } inline void TDesignatorList_Delete ( TDesignatorList * p ) { if ( p ) { Array_Destroy ( ( Array * ) p , TDesignator_DeleteVoid ) ; free ( p ) ; } } 



typedef TTypePointer TInitializer;



typedef struct

{

  TDesignatorList*  ^ pDesignatorList;

  TInitializer* pInitializer;

} TInitializerListItem;



inline TInitializerListItem * TInitializerListItem_Create ( ) { TInitializerListItem * p = ( TInitializerListItem * ) malloc ( sizeof * p ) ; if ( p ) { TInitializerListItem temp_Moved = { ( ( void * ) 0 ) , ( ( void * ) 0 ) } ; * p = && temp_Moved ; } return p ; } void TInitializerListItem_Destroy ( TInitializerListItem * p ) ; inline void TInitializerListItem_Delete ( TInitializerListItem * p ) { if ( p ) { TInitializerListItem_Destroy ( p ) ; free ( p ) ; } } inline void TInitializerListItem_DeleteVoid ( void * p ) { TInitializerListItem_Delete ( ( TInitializerListItem * ) p ) ; } 



typedef struct TInitializerList_

{

  TInitializerListItem** pItems;

  size_t size;

  size_t capacity;

} TInitializerList;



inline void TInitializerList_Push ( TInitializerList * p , TInitializerListItem * pItem ) { Array_Push ( ( Array * ) p , pItem ) ; } inline void TInitializerList_Destroy ( TInitializerList * p ) { Array_Destroy ( ( Array * ) p , TInitializerListItem_DeleteVoid ) ; } inline TInitializerList * TInitializerList_Create ( ) { TInitializerList * p = ( TInitializerList * ) malloc ( sizeof * p ) ; if ( p ) { Array_Init ( ( Array * ) p ) ; } return p ; } inline Result TInitializerList_Reserve ( TInitializerList * p , size_t n ) { return Array_Reserve ( ( Array * ) p , n ) ; } inline void TInitializerList_Delete ( TInitializerList * p ) { if ( p ) { Array_Destroy ( ( Array * ) p , TInitializerListItem_DeleteVoid ) ; free ( p ) ; } } 



typedef struct

{

  TTypePointer Type;

  TInitializerList InitializerList;

} TInitializerListType;





inline TInitializerListType * TInitializerListType_Create ( ) { TInitializerListType * p = ( TInitializerListType * ) malloc ( sizeof * p ) ; if ( p ) { TInitializerListType temp_Moved = { { TInitializerListType_ID } , { ( ( void * ) 0 ) , 0 , 0 } } ; * p = && temp_Moved ; } return p ; } void TInitializerListType_Destroy ( TInitializerListType * p ) ; inline void TInitializerListType_Delete ( TInitializerListType * p ) { if ( p ) { TInitializerListType_Destroy ( p ) ; free ( p ) ; } } inline void TInitializerListType_DeleteVoid ( void * p ) { TInitializerListType_Delete ( ( TInitializerListType * ) p ) ; } 







typedef TTypePointer TInitializer ; void TInitializer_Destroy ( TInitializer * p ) ; inline void TInitializer_Delete ( TInitializer * p ) { if ( p ) { TInitializer_Destroy ( p ) ; free ( p ) ; } } inline void TInitializer_DeleteVoid ( void * p ) { TInitializer_Delete ( ( TInitializer * ) p ) ; } 

inline TInitializerListType * TInitializer_As_TInitializerListType ( TInitializer * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TInitializerListType_ID ) return ( TInitializerListType * ) p ; return ( ( void * ) 0 ) ; } inline TInitializer * TInitializerListType_As_TInitializer ( TInitializerListType * p ) { return ( TInitializer * ) p ; } 

inline TExpression2 * TInitializer_As_TExpression2 ( TInitializer * p ) { return p ; } inline TInitializer * TExpression2_As_TInitializer ( TExpression2 * p ) { return p ; } 







typedef struct TDeclarator_S

{

  String Name;

  TTypeQualifier Qualifiers;

  TPointerList PointerList;

  struct TDeclarator_S*  ^ pDeclaratorOpt;

  struct ParameterList_T*  ^ pParametersOpt;

  TInitializer* ^ pInitializer;



  TExpression2*  ^ pExpression;

  Tokens token;

  int nUses;



  

  _Bool bDestructorCalled;

} TDeclarator;





typedef TDeclarator TStructDeclarator;



inline TDeclarator * TDeclarator_Create ( ) { TDeclarator * p = ( TDeclarator * ) malloc ( sizeof * p ) ; if ( p ) { TDeclarator temp_Moved = { ( ( void * ) 0 ) , { 0 , 0 , 0 , 0 , 0 , 0 } , { ( ( void * ) 0 ) , 0 , 0 } , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , TK_NONE , 0 , 0 } ; * p = && temp_Moved ; } return p ; } void TDeclarator_Destroy ( TDeclarator * p ) ; inline void TDeclarator_Delete ( TDeclarator * p ) { if ( p ) { TDeclarator_Destroy ( p ) ; free ( p ) ; } } inline void TDeclarator_DeleteVoid ( void * p ) { TDeclarator_Delete ( ( TDeclarator * ) p ) ; } 

const char* TDeclarator_FindName(TDeclarator* p);



typedef struct

{

  TDeclarator** pItems;

  size_t size;

  size_t capacity;

} TDeclaratorList;



inline void TDeclaratorList_Push ( TDeclaratorList * p , TDeclarator * pItem ) { Array_Push ( ( Array * ) p , pItem ) ; } inline void TDeclaratorList_Destroy ( TDeclaratorList * p ) { Array_Destroy ( ( Array * ) p , TDeclarator_DeleteVoid ) ; } inline TDeclaratorList * TDeclaratorList_Create ( ) { TDeclaratorList * p = ( TDeclaratorList * ) malloc ( sizeof * p ) ; if ( p ) { Array_Init ( ( Array * ) p ) ; } return p ; } inline Result TDeclaratorList_Reserve ( TDeclaratorList * p , size_t n ) { return Array_Reserve ( ( Array * ) p , n ) ; } inline void TDeclaratorList_Delete ( TDeclaratorList * p ) { if ( p ) { Array_Destroy ( ( Array * ) p , TDeclarator_DeleteVoid ) ; free ( p ) ; } } 



typedef TDeclaratorList TStructDeclaratorList;





typedef struct

{

  TTypePointer Type;

  TTypeSpecifier*  ^ pSpecifier;

  TTypeQualifier Qualifier;

  TStructDeclaratorList DeclaratorList;



} TStructDeclaration;





inline TStructDeclaration * TStructDeclaration_Create ( ) { TStructDeclaration * p = ( TStructDeclaration * ) malloc ( sizeof * p ) ; if ( p ) { TStructDeclaration temp_Moved = { { TStructDeclaration_ID } , ( ( void * ) 0 ) , { 0 , 0 , 0 , 0 , 0 , 0 } , { ( ( void * ) 0 ) , 0 , 0 } } ; * p = && temp_Moved ; } return p ; } void TStructDeclaration_Destroy ( TStructDeclaration * p ) ; inline void TStructDeclaration_Delete ( TStructDeclaration * p ) { if ( p ) { TStructDeclaration_Destroy ( p ) ; free ( p ) ; } } inline void TStructDeclaration_DeleteVoid ( void * p ) { TStructDeclaration_Delete ( ( TStructDeclaration * ) p ) ; } 





typedef TTypePointer TAnyStructDeclaration ; void TAnyStructDeclaration_Destroy ( TAnyStructDeclaration * p ) ; inline void TAnyStructDeclaration_Delete ( TAnyStructDeclaration * p ) { if ( p ) { TAnyStructDeclaration_Destroy ( p ) ; free ( p ) ; } } inline void TAnyStructDeclaration_DeleteVoid ( void * p ) { TAnyStructDeclaration_Delete ( ( TAnyStructDeclaration * ) p ) ; } 

inline TStructDeclaration * TAnyStructDeclaration_As_TStructDeclaration ( TAnyStructDeclaration * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TStructDeclaration_ID ) return ( TStructDeclaration * ) p ; return ( ( void * ) 0 ) ; } inline TAnyStructDeclaration * TStructDeclaration_As_TAnyStructDeclaration ( TStructDeclaration * p ) { return ( TAnyStructDeclaration * ) p ; } 

inline TStaticAssertDeclaration * TAnyStructDeclaration_As_TStaticAssertDeclaration ( TAnyStructDeclaration * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TStaticAssertDeclaration_ID ) return ( TStaticAssertDeclaration * ) p ; return ( ( void * ) 0 ) ; } inline TAnyStructDeclaration * TStaticAssertDeclaration_As_TAnyStructDeclaration ( TStaticAssertDeclaration * p ) { return ( TAnyStructDeclaration * ) p ; } 



typedef struct

{

  TAnyStructDeclaration** pItems;

  size_t size;

  size_t capacity;

} TStructDeclarationList;





inline void TStructDeclarationList_Push ( TStructDeclarationList * p , TAnyStructDeclaration * pItem ) { Array_Push ( ( Array * ) p , pItem ) ; } inline void TStructDeclarationList_Destroy ( TStructDeclarationList * p ) { Array_Destroy ( ( Array * ) p , TAnyStructDeclaration_DeleteVoid ) ; } inline TStructDeclarationList * TStructDeclarationList_Create ( ) { TStructDeclarationList * p = ( TStructDeclarationList * ) malloc ( sizeof * p ) ; if ( p ) { Array_Init ( ( Array * ) p ) ; } return p ; } inline Result TStructDeclarationList_Reserve ( TStructDeclarationList * p , size_t n ) { return Array_Reserve ( ( Array * ) p , n ) ; } inline void TStructDeclarationList_Delete ( TStructDeclarationList * p ) { if ( p ) { Array_Destroy ( ( Array * ) p , TAnyStructDeclaration_DeleteVoid ) ; free ( p ) ; } } 



typedef struct

{

  TTypePointer Type;

  TStructDeclarationList StructDeclarationList;

  String Name;

  _Bool bIsStruct;



} TStructUnionSpecifier;





inline TStructUnionSpecifier * TStructUnionSpecifier_Create ( ) { TStructUnionSpecifier * p = ( TStructUnionSpecifier * ) malloc ( sizeof * p ) ; if ( p ) { TStructUnionSpecifier temp_Moved = { { TStructUnionSpecifier_ID } , { ( ( void * ) 0 ) , 0 , 0 } , ( ( void * ) 0 ) , 1 } ; * p = && temp_Moved ; } return p ; } void TStructUnionSpecifier_Destroy ( TStructUnionSpecifier * p ) ; inline void TStructUnionSpecifier_Delete ( TStructUnionSpecifier * p ) { if ( p ) { TStructUnionSpecifier_Destroy ( p ) ; free ( p ) ; } } inline void TStructUnionSpecifier_DeleteVoid ( void * p ) { TStructUnionSpecifier_Delete ( ( TStructUnionSpecifier * ) p ) ; } 





typedef TTypePointer TTypeSpecifier ; void TTypeSpecifier_Destroy ( TTypeSpecifier * p ) ; inline void TTypeSpecifier_Delete ( TTypeSpecifier * p ) { if ( p ) { TTypeSpecifier_Destroy ( p ) ; free ( p ) ; } } inline void TTypeSpecifier_DeleteVoid ( void * p ) { TTypeSpecifier_Delete ( ( TTypeSpecifier * ) p ) ; } 

inline TSingleTypeSpecifier * TTypeSpecifier_As_TSingleTypeSpecifier ( TTypeSpecifier * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TSingleTypeSpecifier_ID ) return ( TSingleTypeSpecifier * ) p ; return ( ( void * ) 0 ) ; } inline TTypeSpecifier * TSingleTypeSpecifier_As_TTypeSpecifier ( TSingleTypeSpecifier * p ) { return ( TTypeSpecifier * ) p ; } 

inline TEnumSpecifier * TTypeSpecifier_As_TEnumSpecifier ( TTypeSpecifier * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TEnumSpecifier_ID ) return ( TEnumSpecifier * ) p ; return ( ( void * ) 0 ) ; } inline TTypeSpecifier * TEnumSpecifier_As_TTypeSpecifier ( TEnumSpecifier * p ) { return ( TTypeSpecifier * ) p ; } 

inline TStructUnionSpecifier * TTypeSpecifier_As_TStructUnionSpecifier ( TTypeSpecifier * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TStructUnionSpecifier_ID ) return ( TStructUnionSpecifier * ) p ; return ( ( void * ) 0 ) ; } inline TTypeSpecifier * TStructUnionSpecifier_As_TTypeSpecifier ( TStructUnionSpecifier * p ) { return ( TTypeSpecifier * ) p ; } 







typedef struct

{

  TTypePointer Type;

  TDeclarationSpecifiers Specifiers;

  TDeclaratorList Declarators;



  

  TCompoundStatement* pCompoundStatementOpt;



  int FileIndex;

  int Line;



} TDeclaration;



inline TDeclaration * TDeclaration_Create ( ) { TDeclaration * p = ( TDeclaration * ) malloc ( sizeof * p ) ; if ( p ) { TDeclaration temp_Moved = { { TDeclaration_ID } , { { 0 , 0 , 0 , 0 , 0 , 0 } , ( ( void * ) 0 ) , { 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 } , { ( ( void * ) 0 ) } } , { ( ( void * ) 0 ) , 0 , 0 } , ( ( void * ) 0 ) , - 1 , - 1 } ; * p = && temp_Moved ; } return p ; } void TDeclaration_Destroy ( TDeclaration * p ) ; inline void TDeclaration_Delete ( TDeclaration * p ) { if ( p ) { TDeclaration_Destroy ( p ) ; free ( p ) ; } } inline void TDeclaration_DeleteVoid ( void * p ) { TDeclaration_Delete ( ( TDeclaration * ) p ) ; } 

_Bool TDeclaration_Is_StructOrUnionDeclaration(TDeclaration* p);

_Bool TDeclaration_Is_FunctionDeclaration(TDeclaration* p);

_Bool TDeclaration_Is_FunctionDefinition(TDeclaration* p);

const char* TDeclaration_GetFunctionThis(TDeclaration* p);

_Bool TDeclaration_Is_EnumDeclaration(TDeclaration* p);

TDeclarator* TDeclaration_FindDeclarator(TDeclaration* p, const char* name);







inline TStaticAssertDeclaration * TAnyDeclaration_As_TStaticAssertDeclaration ( TAnyDeclaration * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TStaticAssertDeclaration_ID ) return ( TStaticAssertDeclaration * ) p ; return ( ( void * ) 0 ) ; } inline TAnyDeclaration * TStaticAssertDeclaration_As_TAnyDeclaration ( TStaticAssertDeclaration * p ) { return ( TAnyDeclaration * ) p ; } 

inline TDeclaration * TAnyDeclaration_As_TDeclaration ( TAnyDeclaration * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TDeclaration_ID ) return ( TDeclaration * ) p ; return ( ( void * ) 0 ) ; } inline TAnyDeclaration * TDeclaration_As_TAnyDeclaration ( TDeclaration * p ) { return ( TAnyDeclaration * ) p ; } 



_Bool TAnyDeclaration_IsTypedef(TAnyDeclaration* pDeclaration);

_Bool TAnyDeclaration_Is_StructOrUnionDeclaration(TAnyDeclaration* pDeclaration);

int TAnyDeclaration_GetFileIndex(TAnyDeclaration* pDeclaration);





typedef struct

{

  TDeclarationSpecifiers Specifiers;

  TDeclarator Declarator;



  

  

  

} TParameterDeclaration;



void TParameterDeclaration_Destroy(TParameterDeclaration* p);



inline TParameterDeclaration * TParameterDeclaration_Create ( ) { TParameterDeclaration * p = ( TParameterDeclaration * ) malloc ( sizeof * p ) ; if ( p ) { TParameterDeclaration temp_Moved = { { { 0 , 0 , 0 , 0 , 0 , 0 } , ( ( void * ) 0 ) , { 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 } , { ( ( void * ) 0 ) } } , { ( ( void * ) 0 ) , { 0 , 0 , 0 , 0 , 0 , 0 } , { ( ( void * ) 0 ) , 0 , 0 } , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , TK_NONE , 0 , 0 } } ; * p = && temp_Moved ; } return p ; } void TParameterDeclaration_Destroy ( TParameterDeclaration * p ) ; inline void TParameterDeclaration_Delete ( TParameterDeclaration * p ) { if ( p ) { TParameterDeclaration_Destroy ( p ) ; free ( p ) ; } } inline void TParameterDeclaration_DeleteVoid ( void * p ) { TParameterDeclaration_Delete ( ( TParameterDeclaration * ) p ) ; } 





typedef struct ParameterList_T

{

  TParameterDeclaration** pItems;

  size_t size;

  size_t capacity;

} TParameterList;



inline void TParameterList_Push ( TParameterList * p , TParameterDeclaration * pItem ) { Array_Push ( ( Array * ) p , pItem ) ; } inline void TParameterList_Destroy ( TParameterList * p ) { Array_Destroy ( ( Array * ) p , TParameterDeclaration_DeleteVoid ) ; } inline TParameterList * TParameterList_Create ( ) { TParameterList * p = ( TParameterList * ) malloc ( sizeof * p ) ; if ( p ) { Array_Init ( ( Array * ) p ) ; } return p ; } inline Result TParameterList_Reserve ( TParameterList * p , size_t n ) { return Array_Reserve ( ( Array * ) p , n ) ; } inline void TParameterList_Delete ( TParameterList * p ) { if ( p ) { Array_Destroy ( ( Array * ) p , TParameterDeclaration_DeleteVoid ) ; free ( p ) ; } } 



typedef struct

{

  TAnyDeclaration** pItems;

  size_t size;

  size_t capacity;

} TDeclarations;



inline void TDeclarations_Push ( TDeclarations * p , TAnyDeclaration * pItem ) { Array_Push ( ( Array * ) p , pItem ) ; } inline void TDeclarations_Destroy ( TDeclarations * p ) { Array_Destroy ( ( Array * ) p , TAnyDeclaration_DeleteVoid ) ; } inline TDeclarations * TDeclarations_Create ( ) { TDeclarations * p = ( TDeclarations * ) malloc ( sizeof * p ) ; if ( p ) { Array_Init ( ( Array * ) p ) ; } return p ; } inline Result TDeclarations_Reserve ( TDeclarations * p , size_t n ) { return Array_Reserve ( ( Array * ) p , n ) ; } inline void TDeclarations_Delete ( TDeclarations * p ) { if ( p ) { Array_Destroy ( ( Array * ) p , TAnyDeclaration_DeleteVoid ) ; free ( p ) ; } } 





typedef MultiMap DeclarationsMap;





Result DeclarationsMap_Init(DeclarationsMap* p, size_t nBuckets);

void DeclarationsMap_Destroy(DeclarationsMap* p);

TDeclaration* DeclarationsMap_FindDeclaration(DeclarationsMap* p, const char* name);

Result DeclarationsMap_Add(DeclarationsMap* p, const char* name, TAnyDeclaration* pData);







typedef struct

{

  

  TDeclarations Declarations;

  

  TFileArray Files2;



  

  DeclarationsMap Symbols;



  

  TMacroMap Defines;



  Map EnumMap;



} TProgram;





void TProgram_Destroy(TProgram* p);

TDeclaration* TProgram_GetFinalTypeDeclaration(TProgram* p, const char* typeName);

TDeclaration* TProgram_FindDeclaration(TProgram* p, const char* name);

TDeclaration* TProgram_FindDestructorDefinition(TProgram* p, const char* name);

TDeclaration* TProgram_FindDestructorDeclaration(TProgram* p, const char* name);





inline TCompoundStatement * TBlockItem_As_TCompoundStatement ( TBlockItem * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TCompoundStatement_ID ) return ( TCompoundStatement * ) p ; return ( ( void * ) 0 ) ; } inline TBlockItem * TCompoundStatement_As_TBlockItem ( TCompoundStatement * p ) { return ( TBlockItem * ) p ; } 

inline TExpressionStatement * TBlockItem_As_TExpressionStatement ( TBlockItem * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TExpressionStatement_ID ) return ( TExpressionStatement * ) p ; return ( ( void * ) 0 ) ; } inline TBlockItem * TExpressionStatement_As_TBlockItem ( TExpressionStatement * p ) { return ( TBlockItem * ) p ; } 

inline TLabeledStatement * TBlockItem_As_TLabeledStatement ( TBlockItem * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TLabeledStatement_ID ) return ( TLabeledStatement * ) p ; return ( ( void * ) 0 ) ; } inline TBlockItem * TLabeledStatement_As_TBlockItem ( TLabeledStatement * p ) { return ( TBlockItem * ) p ; } 

inline TJumpStatement * TBlockItem_As_TJumpStatement ( TBlockItem * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TJumpStatement_ID ) return ( TJumpStatement * ) p ; return ( ( void * ) 0 ) ; } inline TBlockItem * TJumpStatement_As_TBlockItem ( TJumpStatement * p ) { return ( TBlockItem * ) p ; } 

inline TIfStatement * TBlockItem_As_TIfStatement ( TBlockItem * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TIfStatement_ID ) return ( TIfStatement * ) p ; return ( ( void * ) 0 ) ; } inline TBlockItem * TIfStatement_As_TBlockItem ( TIfStatement * p ) { return ( TBlockItem * ) p ; } 

inline TDoStatement * TBlockItem_As_TDoStatement ( TBlockItem * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TDoStatement_ID ) return ( TDoStatement * ) p ; return ( ( void * ) 0 ) ; } inline TBlockItem * TDoStatement_As_TBlockItem ( TDoStatement * p ) { return ( TBlockItem * ) p ; } 

inline TForStatement * TBlockItem_As_TForStatement ( TBlockItem * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TForStatement_ID ) return ( TForStatement * ) p ; return ( ( void * ) 0 ) ; } inline TBlockItem * TForStatement_As_TBlockItem ( TForStatement * p ) { return ( TBlockItem * ) p ; } 

inline TAsmStatement * TBlockItem_As_TAsmStatement ( TBlockItem * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TAsmStatement_ID ) return ( TAsmStatement * ) p ; return ( ( void * ) 0 ) ; } inline TBlockItem * TAsmStatement_As_TBlockItem ( TAsmStatement * p ) { return ( TBlockItem * ) p ; } 

inline TReturnStatement * TBlockItem_As_TReturnStatement ( TBlockItem * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TReturnStatement_ID ) return ( TReturnStatement * ) p ; return ( ( void * ) 0 ) ; } inline TBlockItem * TReturnStatement_As_TBlockItem ( TReturnStatement * p ) { return ( TBlockItem * ) p ; } 

inline TWhileStatement * TBlockItem_As_TWhileStatement ( TBlockItem * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TWhileStatement_ID ) return ( TWhileStatement * ) p ; return ( ( void * ) 0 ) ; } inline TBlockItem * TWhileStatement_As_TBlockItem ( TWhileStatement * p ) { return ( TBlockItem * ) p ; } 

inline TSwitchStatement * TBlockItem_As_TSwitchStatement ( TBlockItem * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TSwitchStatement_ID ) return ( TSwitchStatement * ) p ; return ( ( void * ) 0 ) ; } inline TBlockItem * TSwitchStatement_As_TBlockItem ( TSwitchStatement * p ) { return ( TBlockItem * ) p ; } 



inline TDeclaration * TBlockItem_As_TDeclaration ( TBlockItem * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TDeclaration_ID ) return ( TDeclaration * ) p ; return ( ( void * ) 0 ) ; } inline TBlockItem * TDeclaration_As_TBlockItem ( TDeclaration * p ) { return ( TBlockItem * ) p ; } 

inline TStaticAssertDeclaration * TBlockItem_As_TStaticAssertDeclaration ( TBlockItem * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TStaticAssertDeclaration_ID ) return ( TStaticAssertDeclaration * ) p ; return ( ( void * ) 0 ) ; } inline TBlockItem * TStaticAssertDeclaration_As_TBlockItem ( TStaticAssertDeclaration * p ) { return ( TBlockItem * ) p ; } 









typedef struct  {

	TTypeQualifier qualifiers;

	TTypeSpecifier* pTypeSpecifier;

	TDeclarator declarator;

} TTypeName;



void TTypeName_Destroy(TTypeName* p);

void TTypeName_Swap(TTypeName* p1, TTypeName* p2);





struct TTypeName_;



typedef struct

{

	TTypePointer Type;

	TExpression2*  ^ pExpression;

	TTypeName TypeName;

} TCastExpressionType;



inline TCastExpressionType * TCastExpressionType_Create ( ) { TCastExpressionType * p = ( TCastExpressionType * ) malloc ( sizeof * p ) ; if ( p ) { TCastExpressionType temp_Moved = { { TCastExpressionType_ID } , ( ( void * ) 0 ) , { { 0 , 0 , 0 , 0 , 0 , 0 } , ( ( void * ) 0 ) , { ( ( void * ) 0 ) , { 0 , 0 , 0 , 0 , 0 , 0 } , { ( ( void * ) 0 ) , 0 , 0 } , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , TK_NONE , 0 , 0 } } } ; * p = && temp_Moved ; } return p ; } void TCastExpressionType_Destroy ( TCastExpressionType * p ) ; inline void TCastExpressionType_Delete ( TCastExpressionType * p ) { if ( p ) { TCastExpressionType_Destroy ( p ) ; free ( p ) ; } } inline void TCastExpressionType_DeleteVoid ( void * p ) { TCastExpressionType_Delete ( ( TCastExpressionType * ) p ) ; } 









typedef struct

{

	TTypePointer Type;

	Tokens token;

	TExpression2* ^ pExpressionLeft;

	TTypeName TypeName;

} TUnaryExpressionOperator;





inline TUnaryExpressionOperator * TUnaryExpressionOperator_Create ( ) { TUnaryExpressionOperator * p = ( TUnaryExpressionOperator * ) malloc ( sizeof * p ) ; if ( p ) { TUnaryExpressionOperator temp_Moved = { { TUnaryExpressionOperator_ID } , TK_NONE , ( ( void * ) 0 ) , { { 0 , 0 , 0 , 0 , 0 , 0 } , ( ( void * ) 0 ) , { ( ( void * ) 0 ) , { 0 , 0 , 0 , 0 , 0 , 0 } , { ( ( void * ) 0 ) , 0 , 0 } , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , TK_NONE , 0 , 0 } } } ; * p = && temp_Moved ; } return p ; } void TUnaryExpressionOperator_Destroy ( TUnaryExpressionOperator * p ) ; inline void TUnaryExpressionOperator_Delete ( TUnaryExpressionOperator * p ) { if ( p ) { TUnaryExpressionOperator_Destroy ( p ) ; free ( p ) ; } } inline void TUnaryExpressionOperator_DeleteVoid ( void * p ) { TUnaryExpressionOperator_Delete ( ( TUnaryExpressionOperator * ) p ) ; } 





_Bool EvaluateConstantExpression(TExpression2 * p, int *pResult);





inline TPrimaryExpressionValue * TExpression2_As_TPrimaryExpressionValue ( TExpression2 * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TPrimaryExpressionValue_ID ) return ( TPrimaryExpressionValue * ) p ; return ( ( void * ) 0 ) ; } inline TExpression2 * TPrimaryExpressionValue_As_TExpression2 ( TPrimaryExpressionValue * p ) { return ( TExpression2 * ) p ; } 

inline TBinaryExpression * TExpression2_As_TBinaryExpression ( TExpression2 * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TBinaryExpression_ID ) return ( TBinaryExpression * ) p ; return ( ( void * ) 0 ) ; } inline TExpression2 * TBinaryExpression_As_TExpression2 ( TBinaryExpression * p ) { return ( TExpression2 * ) p ; } 

inline TUnaryExpressionOperator * TExpression2_As_TUnaryExpressionOperator ( TExpression2 * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TUnaryExpressionOperator_ID ) return ( TUnaryExpressionOperator * ) p ; return ( ( void * ) 0 ) ; } inline TExpression2 * TUnaryExpressionOperator_As_TExpression2 ( TUnaryExpressionOperator * p ) { return ( TExpression2 * ) p ; } 

inline TPostfixExpressionCore * TExpression2_As_TPostfixExpressionCore ( TExpression2 * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TPostfixExpressionCore_ID ) return ( TPostfixExpressionCore * ) p ; return ( ( void * ) 0 ) ; } inline TExpression2 * TPostfixExpressionCore_As_TExpression2 ( TPostfixExpressionCore * p ) { return ( TExpression2 * ) p ; } 

inline TCastExpressionType * TExpression2_As_TCastExpressionType ( TExpression2 * p ) { if ( p != ( ( void * ) 0 ) && p -> type == TCastExpressionType_ID ) return ( TCastExpressionType * ) p ; return ( ( void * ) 0 ) ; } inline TExpression2 * TCastExpressionType_As_TExpression2 ( TCastExpressionType * p ) { return ( TExpression2 * ) p ; } 

















typedef struct

{

    

    _Bool bError;



    

    StrBuilder ErrorMessage;



    

    Scanner Scanner;



    

    

    

    DeclarationsMap  Symbols;



	Map EnumMap;



} Parser;



Result Parser_InitFile(Parser* parser, const char* fileName);



Result Parser_InitString(Parser* parser,

                         const char* name,

                         const char* text,

                         _Bool bExpressionMode);



void Parser_Destroy(Parser* parser);





const char* GetCompletationMessage(Parser* parser);





_Bool GetAST(const char * filename,

            const char * configFileName,

            TProgram* pProgram);



Result MatchAndGet(Parser* parser, ScannerItem* scannerItem);

Tokens MatchToken(Parser* parser, Tokens tk);

void ConstantExpression(Parser* ctx, TExpression2** ppExpression);







_Bool IsTypeName(Parser* ctx, Tokens token, const char * lexeme);









_Bool DeclarationsMap_IsTypeDef(DeclarationsMap* map, const char* name)

{

	_Bool bResult = 0 ;

	Bucket* p = MultiMap_FindBucket(map, name);



	if (p != ( ( void * ) 0 ) )

	{

		for (size_t i = 0; i < p->size; i++)

		{

			if (strcmp(name, p->data[i]->key) == 0)

			{

				TAnyDeclaration *pDeclaration = (TAnyDeclaration *)p->data[i]->data;

				bResult = TAnyDeclaration_IsTypedef(pDeclaration);



				if (bResult)

					break;

			}

		}

	}



	return bResult;

}



Result Parser_InitString(Parser* parser,

	const char* name,

	const char* text,

	_Bool bExpressionMode)

{

	MultiMap_Init(&parser->Symbols, 1000 );

	Map_Init(&parser->EnumMap, 1000 );



	

	parser->bError = 0 ;

	StrBuilder_Init(&parser->ErrorMessage, 100);

	

	





	

	Scanner_InitString(&parser->Scanner, name, text, bExpressionMode);



	return RESULT_OK;

}



Result Parser_InitFile(Parser* parser, const char* fileName)

{

	DeclarationsMap_Init(&parser->Symbols, 1000 );

	Map_Init(&parser->EnumMap, 1000 );



	

	parser->bError = 0 ;

	

	StrBuilder_Init(&parser->ErrorMessage, 100);

	Scanner_Init(&parser->Scanner);





	

	Scanner_IncludeFile(&parser->Scanner, fileName, FileIncludeTypeFullPath);

	Scanner_Skip(&parser->Scanner);



	return RESULT_OK;

}



void Parser_PushFile(Parser* parser, const char* fileName)

{

	Scanner_IncludeFile(&parser->Scanner, fileName, FileIncludeTypeFullPath);

	Scanner_Skip(&parser->Scanner);

}





void Parser_SetSymbol(Parser* parser,

	const char* name,

	TAnyDeclaration* pObject)

{

	Bucket* pBucket = MultiMap_FindBucket(&parser->Symbols, name);



	if (pBucket)

	{

		

	}



	MultiMap_Add(&parser->Symbols, name, pObject);

	

	

	

	

	

	

	

}



Result DeclarationsMap_Init(DeclarationsMap* p, size_t nBuckets)

{

	return MultiMap_Init(p, nBuckets);

}



void DeclarationsMap_Destroy(DeclarationsMap* p)

{

	MultiMap_Destroy(p, ( ( void * ) 0 ) ); 

}



void Parser_Destroy(Parser* parser)

{

	DeclarationsMap_Destroy(&parser->Symbols);

	Map_Destroy(&parser->EnumMap, ( ( void * ) 0 ) ); 



	

	StrBuilder_Destroy(&parser->ErrorMessage);

	Scanner_Destroy(&parser->Scanner);

}



static const char* GetName()

{

	static char buffer[2];

	buffer[0] = '\0';

	

	

	

	

	

	

	return buffer;

}



static _Bool HasErrors(Parser* pParser)

{

	return pParser->bError || pParser->Scanner.bError;

}





static void Next(Parser* parser)

{

	if (HasErrors(parser))

	{

		return;

	}



	Scanner_Next(&parser->Scanner);

}





void SetError2(Parser* parser, const char* message, const char* message2)

{

	

	if (!HasErrors(parser))

	{

		Scanner_GetError(&parser->Scanner, &parser->ErrorMessage);

		parser->bError = 1 ;

		StrBuilder_Append(&parser->ErrorMessage, "(");

		StrBuilder_AppendInt(&parser->ErrorMessage, Scanner_Line(&parser->Scanner));

		StrBuilder_Append(&parser->ErrorMessage, ") : error :");

		StrBuilder_Append(&parser->ErrorMessage, message);

		StrBuilder_Append(&parser->ErrorMessage, message2);

	}



	else

	{

		

		parser->bError = 1 ;

	}

}



void SetError(Parser* parser, const char* message)

{

	SetError2(parser, message, "");

}



Result MatchAndGet(Parser* parser, ScannerItem* scannerItem)

{

	if (HasErrors(parser))

		return RESULT_FAIL;



	Scanner_GetScannerItemCopy(&parser->Scanner, scannerItem);

	



	Next(parser);

	return RESULT_OK;

}



Result MatchAndPush(Parser* parser, ScannerItemStack* stack)

{

	ScannerItem item;

	ScannerItem_Init(&item);

	MatchAndGet(parser, &item);

	ScannerItemStack_PushMove(stack, &item);

	ScannerItem_Destroy(&item);

	return RESULT_OK;

}



int GetCurrentLine(Parser* parser)

{

	if (HasErrors(parser))

	{

		return -1;

	}



	return Scanner_GetCurrentLine(&parser->Scanner);

}



int GetFileIndex(Parser* parser)

{

	if (HasErrors(parser))

	{

		return -1;

	}



	return Scanner_GetFileIndex(&parser->Scanner);

}



Tokens LookAheadToken(Parser* parser)

{

	if (HasErrors(parser))

	{

		return TK_ERROR;

	}



	return Scanner_GetLookAhead(&parser->Scanner)->token;

}



const char* LookAheadLexeme(Parser* parser)

{

	if (HasErrors(parser))

	{

		return "";

	}



	return Scanner_GetLookAhead(&parser->Scanner)->lexeme.c_str;

}





Tokens Token(Parser* parser)

{

	if (HasErrors(parser))

	{

		return TK_ERROR;

	}



	return Scanner_Token(&parser->Scanner);

}



Tokens Match(Parser* parser)

{

	if (HasErrors(parser))

	{

		return TK_EOF;

	}



	Next(parser);

	return Token(parser);

}













Tokens MatchToken(Parser* parser, Tokens tk)

{

	if (HasErrors(parser))

	{

		return TK_EOF;

	}



	Tokens currentToken = Token(parser);



	if (tk != currentToken)

	{

		SetError2(parser, "Unexpected token - ", TokenToString(tk));

		return TK_EOF;

	}



	Next(parser);

	return Token(parser);

}



const char* GetCompletationMessage(Parser* parser)

{

	const char* pMessage = "ok";



	if (HasErrors(parser))

	{

		if (parser->Scanner.bError)

		{

			pMessage = parser->Scanner.ErrorString.c_str;

		}



		else

		{

			pMessage = parser->ErrorMessage.c_str;

		}

	}



	return pMessage;

}



const char* Lexeme(Parser* parser)

{

	if (HasErrors(parser))

	{

		( void ) ( ( ! ! ( ( 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"0" ) ) || ( __debugbreak ( ) , 0 ) ) ;

		return "";

	}



	return Scanner_Lexeme(&parser->Scanner);

}



_Bool ErrorOrEof(Parser* parser)

{

	return HasErrors(parser) ||

		Token(parser) == TK_EOF;

}











void Expression0(Parser* ctx, TExpression2**);

void CastExpression(Parser* ctx, TExpression2**);

void GenericSelection(Parser* ctx);

void ArgumentExpressionList(Parser* ctx, TExpression2**);

void AssignmentExpression(Parser* ctx, TExpression2**);

void Initializer_List(Parser* ctx, TInitializerList* pInitializerList);

void Specifier_Qualifier_List(Parser* ctx,

	TTypeQualifier* pQualifiers,

	TTypeSpecifier** ppTypeSpecifier);

_Bool AbstractDeclaratorOpt(Parser* ctx, TDeclarator* pTDeclarator2);







_Bool IsFirstOfPrimaryExpression(Tokens token)

{

	_Bool bResult = 0 ;



	switch (token)

	{

		case TK_identifier:

		case TK_string_literal:

		case TK_char_literal:

		case TK_DECIMAL_INTEGER:

		case TK_HEX_INTEGER:

		case TK_FLOAT_NUMBER:

		case TK_LEFT_PARENTHESIS:



			

		case TK__Generic:

			bResult = 1 ;

			break;



		default:

			break;

	}



	return bResult;

}



void PrimaryExpression(Parser* ctx, TExpression2** ppPrimaryExpression)

{

	



	Tokens token = Token(ctx);

	( void ) ( ( ! ! ( ( IsFirstOfPrimaryExpression ( token ) ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"IsFirstOfPrimaryExpression ( token )" ) ) || ( __debugbreak ( ) , 0 ) ) ;



	if (!IsFirstOfPrimaryExpression(token))

	{

		SetError(ctx, "1");

	}



	switch (token)

	{

		case TK_string_literal:

		{

			TPrimaryExpressionValue *pPrimaryExpressionValue

				= TPrimaryExpressionValue_Create();



			pPrimaryExpressionValue->token = token;



			StrBuilder adjacentStrings = { 0 , 0 , 0 } ;

			StrBuilder_Append(&adjacentStrings, "\"");

			while (token == TK_string_literal)

			{

				const char* lexeme = Lexeme(ctx);

				int len = strlen(lexeme);

				StrBuilder_AppendN(&adjacentStrings, lexeme + 1, len - 2);

				token = Match(ctx);

			}

			StrBuilder_Append(&adjacentStrings, "\"");

			String_Set(&pPrimaryExpressionValue->lexeme, adjacentStrings.c_str);

			*ppPrimaryExpression = (TExpression2*)pPrimaryExpressionValue;



			StrBuilder_Destroy(&adjacentStrings);

		}

		break;



		case TK_identifier:

		case TK_char_literal:

		case TK_DECIMAL_INTEGER:

		case TK_HEX_INTEGER:

		case TK_FLOAT_NUMBER:

		{

			TPrimaryExpressionValue *pPrimaryExpressionValue

				= TPrimaryExpressionValue_Create();



			pPrimaryExpressionValue->token = token;

			String_Set(&pPrimaryExpressionValue->lexeme, Lexeme(ctx));



			Match(ctx);

			*ppPrimaryExpression = (TExpression2*)pPrimaryExpressionValue;

		}

		break;



		case TK_LEFT_PARENTHESIS:

		{

			Match(ctx);

			TExpression2* pExpression;

			Expression0(ctx, &pExpression);

			MatchToken(ctx, TK_RIGHT_PARENTHESIS);



			TPrimaryExpressionValue *pPrimaryExpressionValue

				= TPrimaryExpressionValue_Create();



			pPrimaryExpressionValue->token = token;

			String_Set(&pPrimaryExpressionValue->lexeme, Lexeme(ctx));

			pPrimaryExpressionValue->pExpressionOpt = pExpression;

			*ppPrimaryExpression = (TExpression2*)pPrimaryExpressionValue;

		}

		break;



		case TK__Generic:

			GenericSelection(ctx);

			break;



		default:

			( void ) ( ( ! ! ( ( 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"0" ) ) || ( __debugbreak ( ) , 0 ) ) ;

	}



	( void ) ( ( ! ! ( ( * ppPrimaryExpression != ( ( void * ) 0 ) ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"* ppPrimaryExpression != ( ( void * ) 0 )" ) ) || ( __debugbreak ( ) , 0 ) ) ;

}



void GenericSelection(Parser* ctx)

{

	



	

}



void GenericAssocList(Parser* ctx)

{



	



	

}



void GenericAssociation(Parser* ctx)

{

	



	

}



void TypeName(Parser* ctx, TTypeName* pTypeName)

{

	



	Specifier_Qualifier_List(ctx,

		&pTypeName->qualifiers,

		&pTypeName->pTypeSpecifier);



	AbstractDeclaratorOpt(ctx, &pTypeName->declarator);

}





void PostfixExpressionCore(Parser* ctx, TPostfixExpressionCore* pPostfixExpressionCore)

{

	

	



	Tokens token = Token(ctx);





	switch (token)

	{

		case TK_LEFT_PARENTHESIS:

		{

			pPostfixExpressionCore->token = token;



			

			token = Match(ctx);



			if (token != TK_RIGHT_PARENTHESIS)

			{

				ArgumentExpressionList(ctx, &pPostfixExpressionCore->pExpressionArray);

			}



			MatchToken(ctx, TK_RIGHT_PARENTHESIS);

		}

		break;



		case TK_LEFT_SQUARE_BRACKET:

		{

			pPostfixExpressionCore->token = token;

			

			MatchToken(ctx, TK_LEFT_SQUARE_BRACKET);

			Expression0(ctx, &pPostfixExpressionCore->pExpressionArray);

			MatchToken(ctx, TK_RIGHT_SQUARE_BRACKET);

		}

		break;



		case TK_FULL_STOP:

		{

			

			pPostfixExpressionCore->token = token;

			Match(ctx);

			String_Set(&pPostfixExpressionCore->Identifier, Lexeme(ctx));

			MatchToken(ctx, TK_identifier);

		}

		break;



		case TK_ARROW:

		{

			

			pPostfixExpressionCore->token = token;

			Match(ctx);

			String_Set(&pPostfixExpressionCore->Identifier, Lexeme(ctx));

			MatchToken(ctx, TK_identifier);

		}

		break;



		case TK_PLUSPLUS:

		{

			pPostfixExpressionCore->token = token;

			

			Match(ctx);

		}

		break;



		case TK_MINUSMINUS:

		{

			

			pPostfixExpressionCore->token = token;

			Match(ctx);

		}

		break;



		default:

			

			break;

	}





	token = Token(ctx);



	switch (token)

	{

		case TK_LEFT_PARENTHESIS:

		case TK_LEFT_SQUARE_BRACKET:

		case TK_FULL_STOP:

		case TK_ARROW:

		case TK_PLUSPLUS:

		case TK_MINUSMINUS:

		{

			TPostfixExpressionCore * pPostfixExpressionCoreNext =

				TPostfixExpressionCore_Create();

			PostfixExpressionCore(ctx, pPostfixExpressionCoreNext);



			pPostfixExpressionCore->pNext = pPostfixExpressionCoreNext;

		}

		break;

	}





}



void PostfixExpression(Parser* ctx, TExpression2** ppExpression)

{

	*ppExpression = ( ( void * ) 0 ) ;



	



	Tokens token = Token(ctx);





	if (token == TK_LEFT_PARENTHESIS)

	{

		const char* lookAheadlexeme = LookAheadLexeme(ctx);

		Tokens lookAheadToken = LookAheadToken(ctx);



		if (IsTypeName(ctx, lookAheadToken, lookAheadlexeme))

		{

			



			TPostfixExpressionCore * pTPostfixExpressionCore =

				TPostfixExpressionCore_Create();



			MatchToken(ctx, TK_LEFT_PARENTHESIS);



			TTypeName typeName = { { 0 , 0 , 0 , 0 , 0 , 0 } , ( ( void * ) 0 ) , { ( ( void * ) 0 ) , { 0 , 0 , 0 , 0 , 0 , 0 } , { ( ( void * ) 0 ) , 0 , 0 } , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , TK_NONE , 0 , 0 } } ;

			TypeName(ctx, &typeName);

			TTypeName_Destroy(&typeName);



			MatchToken(ctx, TK_RIGHT_PARENTHESIS);



			MatchToken(ctx, TK_LEFT_CURLY_BRACKET);



			pTPostfixExpressionCore->pInitializerList = TInitializerList_Create();

			Initializer_List(ctx, pTPostfixExpressionCore->pInitializerList);

			MatchToken(ctx, TK_RIGHT_CURLY_BRACKET);



			if (Token(ctx) == TK_COMMA)

			{

				Match(ctx);

			}



			*ppExpression = (TExpression2*)pTPostfixExpressionCore;

		}



		else

		{

			

			TExpression2* pPrimaryExpression;

			PrimaryExpression(ctx, &pPrimaryExpression);

			*ppExpression = pPrimaryExpression;

		}

	}



	else

	{

		

		TExpression2* pPrimaryExpression;

		PrimaryExpression(ctx, &pPrimaryExpression);

		*ppExpression = pPrimaryExpression;

	}



	token = Token(ctx);



	switch (token)

	{

		case TK_LEFT_PARENTHESIS:

		case TK_LEFT_SQUARE_BRACKET:

		case TK_FULL_STOP:

		case TK_ARROW:

		case TK_PLUSPLUS:

		case TK_MINUSMINUS:

		{

			TPostfixExpressionCore * pPostfixExpressionCore =

				TPostfixExpressionCore_Create();

			pPostfixExpressionCore->pExpressionLeft = *ppExpression;

			PostfixExpressionCore(ctx, pPostfixExpressionCore);

			*ppExpression = (TExpression2*)pPostfixExpressionCore;

		}

		break;

	}



}



void ArgumentExpressionList(Parser* ctx, TExpression2** ppExpression)

{

	

	TExpression2* pAssignmentExpression;

	AssignmentExpression(ctx, &pAssignmentExpression);

	*ppExpression = pAssignmentExpression;



	Tokens token = Token(ctx);



	if (token == TK_COMMA)

	{

		Match(ctx);

		TExpression2* pAssignmentExpressionRight;

		AssignmentExpression(ctx, &pAssignmentExpressionRight);



		TBinaryExpression * pExpr =

			TBinaryExpression_Create();

		pExpr->token = TK_COMMA;

		pExpr->pExpressionLeft = pAssignmentExpression;

		pExpr->pExpressionRight = pAssignmentExpressionRight;

		*ppExpression = (TExpression2*)pExpr;

	}



	token = Token(ctx);



	if (token == TK_COMMA)

	{

		Match(ctx);

		TBinaryExpression * pExpr =

			TBinaryExpression_Create();



		pExpr->token = TK_COMMA;

		pExpr->pExpressionLeft = *ppExpression;



		TExpression2 *pExpressionRight;

		ArgumentExpressionList(ctx, &pExpressionRight);

		pExpr->pExpressionRight = pExpressionRight;

		*ppExpression = (TExpression2*)pExpr;

	}

}



static _Bool IsTypeQualifierToken(Tokens token)

{

	_Bool bResult = 0 ;

	switch (token)

	{

		

		case TK_const:

		case TK_restrict:

		case TK_volatile:

		case TK__Atomic:

		

			bResult = 1 ;

			break;

		

		case TK_QUESTION_MARK:

		case TK_CIRCUMFLEX_ACCENT:

			bResult = 1 ;

			break;

	}

	return bResult;

}



_Bool IsTypeName(Parser* ctx, Tokens token, const char * lexeme)

{

	_Bool bResult = 0 ;



	switch (token)

	{



		case TK_identifier:

			bResult = DeclarationsMap_IsTypeDef(&ctx->Symbols, lexeme);

			break;



		

		case TK_const:

		case TK_restrict:

		case TK_volatile:

		case TK__Atomic:

		

		

		case TK_QUESTION_MARK:

		case TK_CIRCUMFLEX_ACCENT:

			



			

		case TK_void:

		case TK_char:

		case TK_short:

		case TK_int:

		case TK_long:

		case TK_float:

		case TK_double:

		case TK_signed:

		case TK_unsigned:

		case TK__Bool:

		case TK__Complex:

		case TK_struct:

		case TK_union:

		case TK_enum:

			bResult = 1 ;

			break;

	}



	return bResult;

}



void UnaryExpression(Parser* ctx, TExpression2** ppExpression)

{

	*ppExpression = ( ( void * ) 0 ) ; 



	



	Tokens token0 = Token(ctx);

	Tokens tokenAhead = LookAheadToken(ctx);

	const char* lookAheadlexeme = LookAheadLexeme(ctx);



	if (IsTypeName(ctx, tokenAhead, lookAheadlexeme))

	{

		

		TExpression2 * pPostfixExpression;

		PostfixExpression(ctx, &pPostfixExpression);

		*ppExpression = (TExpression2*)(pPostfixExpression);

		return;

	}



	else if (IsFirstOfPrimaryExpression(token0))

	{

		



		TExpression2 * pPostfixExpression;

		PostfixExpression(ctx, &pPostfixExpression);

		*ppExpression = (TExpression2*)(pPostfixExpression);

		return;

	}



	switch (token0)

	{

		case TK_PLUSPLUS:

		case TK_MINUSMINUS:

		{

			Match(ctx);

			TExpression2 *pUnaryExpression;

			UnaryExpression(ctx, &pUnaryExpression);



			TUnaryExpressionOperator* pUnaryExpressionOperator =

				TUnaryExpressionOperator_Create();

			pUnaryExpressionOperator->token = token0;

			pUnaryExpressionOperator->pExpressionLeft = pUnaryExpression;

			*ppExpression = (TExpression2*)pUnaryExpressionOperator;

		}

		break;



		

		case TK_AMPERSAND:

		case TK_ASTERISK:

		case TK_PLUS_SIGN:

		case TK_HYPHEN_MINUS:

		case TK_TILDE:

		case TK_EXCLAMATION_MARK:

		

		case TK_ANDAND: 

	    

		{

			Match(ctx);

			TExpression2* pCastExpression;

			CastExpression(ctx, &pCastExpression);





			TUnaryExpressionOperator* pUnaryExpressionOperator =

				TUnaryExpressionOperator_Create();

			pUnaryExpressionOperator->token = token0;

			pUnaryExpressionOperator->pExpressionLeft = pCastExpression;

			*ppExpression = (TExpression2*)pUnaryExpressionOperator;



		}

		break;



		



		case TK_SIZEOF:

			MatchToken(ctx, TK_SIZEOF);



			if (Token(ctx) == TK_LEFT_PARENTHESIS)

			{

				const char* lookAheadlexeme = LookAheadLexeme(ctx);

				Tokens lookAheadToken = LookAheadToken(ctx);



				if (IsTypeName(ctx, lookAheadToken, lookAheadlexeme))

				{

					TUnaryExpressionOperator* pUnaryExpressionOperator =

						TUnaryExpressionOperator_Create();







					

					MatchToken(ctx, TK_LEFT_PARENTHESIS);



					TypeName(ctx, &pUnaryExpressionOperator->TypeName);



					MatchToken(ctx, TK_RIGHT_PARENTHESIS);







					pUnaryExpressionOperator->token = token0;

					

					*ppExpression = (TExpression2*)pUnaryExpressionOperator;



				}



				else

				{

					

					TExpression2 *pTUnaryExpression;

					UnaryExpression(ctx, &pTUnaryExpression);



					TUnaryExpressionOperator* pUnaryExpressionOperator =

						TUnaryExpressionOperator_Create();

					pUnaryExpressionOperator->token = token0;

					pUnaryExpressionOperator->pExpressionLeft = pTUnaryExpression;

					*ppExpression = (TExpression2*)pUnaryExpressionOperator;



				}

			}



			else

			{

				

				TExpression2 *pTUnaryExpression;

				UnaryExpression(ctx, &pTUnaryExpression);



				TUnaryExpressionOperator* pUnaryExpressionOperator =

					TUnaryExpressionOperator_Create();

				pUnaryExpressionOperator->token = token0;

				pUnaryExpressionOperator->pExpressionLeft = pTUnaryExpression;

				*ppExpression = (TExpression2*)pUnaryExpressionOperator;

			}



			break;



		case TK__Alignof:

			

			( void ) ( ( ! ! ( ( 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"0" ) ) || ( __debugbreak ( ) , 0 ) ) ;

			break;



		default:

			( void ) ( ( ! ! ( ( 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"0" ) ) || ( __debugbreak ( ) , 0 ) ) ;

			break;

	}



}



void CastExpression(Parser* ctx, TExpression2** ppExpression)

{

	*ppExpression = ( ( void * ) 0 ) ; 



	



	Tokens token = Token(ctx);



	if (token == TK_LEFT_PARENTHESIS)

	{

		const char* lookAheadlexeme = LookAheadLexeme(ctx);

		Tokens lookAheadToken = LookAheadToken(ctx);



		if (IsTypeName(ctx, lookAheadToken, lookAheadlexeme))

		{

			MatchToken(ctx, TK_LEFT_PARENTHESIS);

			TTypeName typeName = { { 0 , 0 , 0 , 0 , 0 , 0 } , ( ( void * ) 0 ) , { ( ( void * ) 0 ) , { 0 , 0 , 0 , 0 , 0 , 0 } , { ( ( void * ) 0 ) , 0 , 0 } , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) , TK_NONE , 0 , 0 } } ;

			TypeName(ctx, &typeName);



			token = MatchToken(ctx, TK_RIGHT_PARENTHESIS);



			if (token == TK_LEFT_CURLY_BRACKET)

			{

				

				

				

				



				MatchToken(ctx, TK_LEFT_CURLY_BRACKET);



				TPostfixExpressionCore*  pTPostfixExpressionCore =

					TPostfixExpressionCore_Create();



				pTPostfixExpressionCore->pInitializerList = TInitializerList_Create();

				Initializer_List(ctx, pTPostfixExpressionCore->pInitializerList);



				Initializer_List(ctx, pTPostfixExpressionCore->pInitializerList);

				MatchToken(ctx, TK_RIGHT_CURLY_BRACKET);





				if (Token(ctx) == TK_COMMA)

				{

					Match(ctx);

				}





				PostfixExpressionCore(ctx, pTPostfixExpressionCore);

			}

			else

			{

				TExpression2* pCastExpression;

				CastExpression(ctx, &pCastExpression);



				TCastExpressionType *pCastExpressionType =

					TCastExpressionType_Create();



				TTypeName_Swap(&pCastExpressionType->TypeName, &typeName);

				pCastExpressionType->pExpression = pCastExpression;

				*ppExpression = (TExpression2*)pCastExpressionType;



			}



			TTypeName_Destroy(&typeName);

		}

		else

		{

			TExpression2* pUnaryExpression;

			UnaryExpression(ctx, &pUnaryExpression);

			*ppExpression = pUnaryExpression;

		}

	}

	else

	{

		TExpression2* pUnaryExpression;

		UnaryExpression(ctx, &pUnaryExpression);

		

		*ppExpression = pUnaryExpression;

	}

}





void MultiplicativeExpression(Parser* ctx, TExpression2** ppExpression)

{





	



	TExpression2* pExpressionLeft;

	CastExpression(ctx, &pExpressionLeft);

	*ppExpression = pExpressionLeft;



	Tokens token = Token(ctx);





	switch (token)

	{

		case TK_PERCENT_SIGN:

		case TK_SOLIDUS:

		case TK_ASTERISK:

		{

			TBinaryExpression *pBinaryExpression = TBinaryExpression_Create();

			pBinaryExpression->token = token;

			pBinaryExpression->pExpressionLeft = *ppExpression;

			Match(ctx);

			TExpression2* pExpressionRight;

			CastExpression(ctx, &pExpressionRight);

			pBinaryExpression->pExpressionRight = pExpressionRight;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;

	}



	token = Token(ctx);



	switch (token)

	{

		case TK_PERCENT_SIGN:

		case TK_SOLIDUS:

		case TK_ASTERISK:

		{

			TBinaryExpression *pBinaryExpression = TBinaryExpression_Create();

			pBinaryExpression->token = token;

			pBinaryExpression->pExpressionLeft = *ppExpression;

			Match(ctx);

			TExpression2* pExpressionRight;

			MultiplicativeExpression(ctx, &pExpressionRight);

			pBinaryExpression->pExpressionRight = pExpressionRight;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;

	}

}



void AdditiveExpression(Parser* ctx, TExpression2** ppExpression)

{



	



	TExpression2* pExpressionLeft;

	MultiplicativeExpression(ctx, &pExpressionLeft);

	*ppExpression = pExpressionLeft;



	Tokens token = Token(ctx);





	switch (token)

	{

		case TK_PLUS_SIGN:

		case TK_HYPHEN_MINUS:

		{

			TBinaryExpression *pBinaryExpression = TBinaryExpression_Create();

			pBinaryExpression->token = token;

			pBinaryExpression->pExpressionLeft = *ppExpression;

			Match(ctx);

			TExpression2* pExpressionRight;

			MultiplicativeExpression(ctx, &pExpressionRight);

			pBinaryExpression->pExpressionRight = pExpressionRight;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;

	}



	token = Token(ctx);



	switch (token)

	{

		case TK_PLUS_SIGN:

		case TK_HYPHEN_MINUS:

		{

			TBinaryExpression *pBinaryExpression = TBinaryExpression_Create();

			pBinaryExpression->token = token;

			pBinaryExpression->pExpressionLeft = *ppExpression;

			Match(ctx);

			TExpression2* pExpressionRight;

			AdditiveExpression(ctx, &pExpressionRight);

			pBinaryExpression->pExpressionRight = pExpressionRight;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;

	}



}



void ShiftExpression(Parser* ctx, TExpression2** ppExpression)

{



	





	TExpression2* pExpressionLeft;

	AdditiveExpression(ctx, &pExpressionLeft);

	*ppExpression = pExpressionLeft;



	Tokens token = Token(ctx);





	switch (token)

	{

		case TK_GREATERGREATER:

		case TK_LESSLESS:

		{

			TBinaryExpression *pBinaryExpression = TBinaryExpression_Create();

			pBinaryExpression->token = token;

			pBinaryExpression->pExpressionLeft = *ppExpression;

			Match(ctx);

			TExpression2* pExpressionRight;

			AdditiveExpression(ctx, &pExpressionRight);

			pBinaryExpression->pExpressionRight = pExpressionRight;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;

	}



	token = Token(ctx);



	switch (token)

	{

		case TK_GREATERGREATER:

		case TK_LESSLESS:

		{

			TBinaryExpression *pBinaryExpression = TBinaryExpression_Create();

			pBinaryExpression->token = token;

			pBinaryExpression->pExpressionLeft = *ppExpression;

			Match(ctx);

			TExpression2* pExpressionRight;

			ShiftExpression(ctx, &pExpressionRight);

			pBinaryExpression->pExpressionRight = pExpressionRight;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;

	}

}



void RelationalExpression(Parser* ctx, TExpression2** ppExpression)

{

	



	TExpression2* pExpressionLeft;

	ShiftExpression(ctx, &pExpressionLeft);

	*ppExpression = pExpressionLeft;



	Tokens token = Token(ctx);





	switch (token)

	{

		case TK_LESS_THAN_SIGN:

		case TK_GREATER_THAN_SIGN:

		case TK_GREATEREQUAL:

		case TK_LESSEQUAL:

		{

			TBinaryExpression *pBinaryExpression = TBinaryExpression_Create();

			pBinaryExpression->token = token;

			pBinaryExpression->pExpressionLeft = *ppExpression;

			Match(ctx);

			TExpression2* pExpressionRight;

			ShiftExpression(ctx, &pExpressionRight);

			pBinaryExpression->pExpressionRight = pExpressionRight;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;

	}



	token = Token(ctx);



	switch (token)

	{

		case TK_LESS_THAN_SIGN:

		case TK_GREATER_THAN_SIGN:

		case TK_GREATEREQUAL:

		case TK_LESSEQUAL:

		{

			TBinaryExpression *pBinaryExpression = TBinaryExpression_Create();

			pBinaryExpression->token = token;

			pBinaryExpression->pExpressionLeft = *ppExpression;

			Match(ctx);

			TExpression2* pExpressionRight;

			RelationalExpression(ctx, &pExpressionRight);

			pBinaryExpression->pExpressionRight = pExpressionRight;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;

	}



}



void EqualityExpression(Parser* ctx, TExpression2** ppExpression)

{

	



	TExpression2* pExpressionLeft;

	RelationalExpression(ctx, &pExpressionLeft);

	*ppExpression = pExpressionLeft;



	Tokens token = Token(ctx);





	switch (token)

	{

		case TK_EQUALEQUAL:

		case TK_NOTEQUAL:

		{

			TBinaryExpression *pBinaryExpression = TBinaryExpression_Create();

			pBinaryExpression->token = token;

			pBinaryExpression->pExpressionLeft = *ppExpression;

			Match(ctx);

			TExpression2* pExpressionRight;

			RelationalExpression(ctx, &pExpressionRight);

			pBinaryExpression->pExpressionRight = pExpressionRight;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;

	}



	token = Token(ctx);



	switch (token)

	{

		case TK_EQUALEQUAL:

		case TK_NOTEQUAL:

		{

			TBinaryExpression *pBinaryExpression = TBinaryExpression_Create();

			pBinaryExpression->token = token;

			pBinaryExpression->pExpressionLeft = *ppExpression;

			Match(ctx);

			TExpression2* pExpressionRight;

			EqualityExpression(ctx, &pExpressionRight);

			pBinaryExpression->pExpressionRight = pExpressionRight;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;

	}

}



void AndExpression(Parser* ctx, TExpression2 **ppExpression)

{

	



	TExpression2* pExpressionLeft;

	EqualityExpression(ctx, &pExpressionLeft);

	*ppExpression = pExpressionLeft;



	Tokens token = Token(ctx);





	switch (token)

	{

		case TK_AMPERSAND:

		{

			TBinaryExpression *pBinaryExpression = TBinaryExpression_Create();

			pBinaryExpression->token = token;

			pBinaryExpression->pExpressionLeft = *ppExpression;

			Match(ctx);

			TExpression2* pExpressionRight;

			EqualityExpression(ctx, &pExpressionRight);

			pBinaryExpression->pExpressionRight = pExpressionRight;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;

	}



	token = Token(ctx);



	switch (token)

	{

		case TK_AMPERSAND:

		{

			TBinaryExpression *pBinaryExpression = TBinaryExpression_Create();

			pBinaryExpression->token = token;

			pBinaryExpression->pExpressionLeft = *ppExpression;

			Match(ctx);

			TExpression2* pExpressionRight;

			AndExpression(ctx, &pExpressionRight);

			pBinaryExpression->pExpressionRight = pExpressionRight;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;

	}

}



void ExclusiveOrExpression(Parser* ctx, TExpression2** ppExpression)

{

	



	TExpression2* pExpressionLeft;

	AndExpression(ctx, &pExpressionLeft);

	*ppExpression = pExpressionLeft;



	Tokens token = Token(ctx);





	switch (token)

	{

		case TK_CIRCUMFLEX_ACCENT:

		{

			TBinaryExpression *pBinaryExpression = TBinaryExpression_Create();

			pBinaryExpression->token = token;

			pBinaryExpression->pExpressionLeft = *ppExpression;

			Match(ctx);

			TExpression2* pExpressionRight;

			AndExpression(ctx, &pExpressionRight);

			pBinaryExpression->pExpressionRight = pExpressionRight;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;

	}



	token = Token(ctx);



	switch (token)

	{

		case TK_CIRCUMFLEX_ACCENT:

		{

			TBinaryExpression *pBinaryExpression = TBinaryExpression_Create();

			pBinaryExpression->token = token;

			pBinaryExpression->pExpressionLeft = *ppExpression;

			Match(ctx);

			TExpression2* pExpressionRight;

			ExclusiveOrExpression(ctx, &pExpressionRight);

			pBinaryExpression->pExpressionRight = pExpressionRight;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;

	}



}



void InclusiveOrExpression(Parser* ctx, TExpression2**ppExpression)

{



	



	TExpression2* pExpressionLeft;

	ExclusiveOrExpression(ctx, &pExpressionLeft);

	*ppExpression = pExpressionLeft;



	Tokens token = Token(ctx);





	switch (token)

	{

		case TK_VERTICAL_LINE:

		{

			TBinaryExpression *pBinaryExpression = TBinaryExpression_Create();

			pBinaryExpression->token = token;

			pBinaryExpression->pExpressionLeft = *ppExpression;

			Match(ctx);

			TExpression2* pExpressionRight;

			ExclusiveOrExpression(ctx, &pExpressionRight);

			pBinaryExpression->pExpressionRight = pExpressionRight;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;

	}



	token = Token(ctx);



	switch (token)

	{

		case TK_VERTICAL_LINE:

		{

			TBinaryExpression *pBinaryExpression = TBinaryExpression_Create();

			pBinaryExpression->token = token;

			pBinaryExpression->pExpressionLeft = *ppExpression;

			Match(ctx);

			TExpression2* pExpressionRight;

			InclusiveOrExpression(ctx, &pExpressionRight);

			pBinaryExpression->pExpressionRight = pExpressionRight;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;

	}

}



void LogicalAndExpression(Parser* ctx, TExpression2** ppExpression)

{



	



	TExpression2* pExpressionLeft;

	InclusiveOrExpression(ctx, &pExpressionLeft);

	*ppExpression = pExpressionLeft;



	Tokens token = Token(ctx);





	switch (token)

	{

		case TK_ANDAND:

		{

			TBinaryExpression *pBinaryExpression = TBinaryExpression_Create();

			pBinaryExpression->token = token;

			pBinaryExpression->pExpressionLeft = *ppExpression;

			Match(ctx);

			TExpression2* pExpressionRight;

			InclusiveOrExpression(ctx, &pExpressionRight);

			pBinaryExpression->pExpressionRight = pExpressionRight;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;

	}



	token = Token(ctx);



	switch (token)

	{

		case TK_ANDAND:

		{

			TBinaryExpression *pBinaryExpression = 

				TBinaryExpression_Create();



			pBinaryExpression->token = token;

			pBinaryExpression->pExpressionLeft = *ppExpression;

			Match(ctx);

			TExpression2* pExpressionRight;

			LogicalAndExpression(ctx, &pExpressionRight);

			pBinaryExpression->pExpressionRight = pExpressionRight;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;

	}

}



void LogicalOrExpression(Parser* ctx, TExpression2** ppExpression)

{

	





	TExpression2* pExpressionLeft;

	LogicalAndExpression(ctx, &pExpressionLeft);

	*ppExpression = pExpressionLeft;



	Tokens token = Token(ctx);





	switch (token)

	{

		case TK_OROR:

		{

			TBinaryExpression *pBinaryExpression = TBinaryExpression_Create();

			pBinaryExpression->token = token;

			pBinaryExpression->pExpressionLeft = *ppExpression;

			Match(ctx);

			TExpression2* pExpressionRight;

			LogicalAndExpression(ctx, &pExpressionRight);

			pBinaryExpression->pExpressionRight = pExpressionRight;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;

	}



	token = Token(ctx);



	switch (token)

	{

		case TK_OROR:

		{

			TBinaryExpression *pBinaryExpression = TBinaryExpression_Create();

			pBinaryExpression->token = token;

			pBinaryExpression->pExpressionLeft = *ppExpression;

			Match(ctx);

			TExpression2* pExpressionRight;

			LogicalOrExpression(ctx, &pExpressionRight);

			pBinaryExpression->pExpressionRight = pExpressionRight;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;

	}

}





void ConditionalExpression(Parser* ctx, TExpression2**ppExpression)

{

	

	TExpression2 * pLogicalOrExpressionLeft;

	LogicalOrExpression(ctx, &pLogicalOrExpressionLeft);

	*ppExpression = pLogicalOrExpressionLeft;



	if (Token(ctx) == TK_QUESTION_MARK)

	{

		Match(ctx);

		TExpression2* pTExpression2;

		Expression0(ctx, &pTExpression2);

		MatchToken(ctx, TK_COLON);



		TExpression2* pConditionalExpressionRight;

		ConditionalExpression(ctx, &pConditionalExpressionRight);



		TTernaryExpression* pTernaryExpression =

			TTernaryExpression_Create();

		pTernaryExpression->token = TK_QUESTION_MARK;

		pTernaryExpression->pExpressionLeft = pLogicalOrExpressionLeft;

		pTernaryExpression->pExpressionMiddle = pTExpression2;

		pTernaryExpression->pExpressionRight = pConditionalExpressionRight;

		*ppExpression = (TExpression2*)pTernaryExpression;

	}





}



void AssignmentExpression(Parser* ctx, TExpression2** ppExpression)

{

	





	

	

	

	

	TExpression2* pConditionalExpressionLeft;

	ConditionalExpression(ctx, &pConditionalExpressionLeft);

	*ppExpression = pConditionalExpressionLeft;



	Tokens token = Token(ctx);



	switch (token)

	{



		case TK_EQUALS_SIGN:

		case TK_MULTIEQUAL:

		case TK_DIVEQUAL:

		case TK_PERCENT_EQUAL:

		case TK_PLUSEQUAL:

		case TK_MINUS_EQUAL:

		case TK_LESSLESSEQUAL:

		case TK_GREATERGREATEREQUAL:

		case TK_ANDEQUAL:

		case TK_CARETEQUAL:

		case TK_OREQUAL:

		{

			Match(ctx);

			

			

			

			TExpression2* pAssignmentExpressionRight;

			AssignmentExpression(ctx, &pAssignmentExpressionRight);



			TBinaryExpression *pBinaryExpression =

				TBinaryExpression_Create();

			pBinaryExpression->pExpressionLeft = *ppExpression;

			pBinaryExpression->pExpressionRight = pAssignmentExpressionRight;

			pBinaryExpression->token = token;

			*ppExpression = (TExpression2*)pBinaryExpression;

		}

		break;



		default:

			

			break;

	}

}



void Expression0(Parser* ctx, TExpression2** ppExpression)

{

	*ppExpression = ( ( void * ) 0 ) ; 

	

	TExpression2* pAssignmentExpressionLeft;

	AssignmentExpression(ctx, &pAssignmentExpressionLeft);

	*ppExpression = pAssignmentExpressionLeft;



	Tokens token = Token(ctx);



	if (token == TK_COMMA)

	{

		TExpression2* pAssignmentExpressionRight;

		Match(ctx);

		Expression0(ctx, &pAssignmentExpressionRight);



		TBinaryExpression* pBinaryExpression =

			TBinaryExpression_Create();

		pBinaryExpression->pExpressionLeft = *ppExpression;

		pBinaryExpression->pExpressionRight = pAssignmentExpressionRight;

		pBinaryExpression->token = TK_COMMA;

		*ppExpression = (TExpression2*)pBinaryExpression;

	}

}



void ConstantExpression(Parser* ctx, TExpression2** ppExpression)

{

	*ppExpression = ( ( void * ) 0 ) ; 



	

	ConditionalExpression(ctx, ppExpression);

}











void Designator(Parser* ctx, TDesignator* pDesignator);

void Designator_List(Parser* ctx, TDesignatorList* pDesignatorList);

void Designation(Parser* ctx, TDesignatorList* pDesignatorList);

void Initializer_List(Parser* ctx, TInitializerList* pInitializerList);



_Bool Statement(Parser* ctx, TStatement** ppStatement);



void Compound_Statement(Parser* ctx, TStatement** ppStatement);

void Expression(Parser* ctx, TExpression2** pExpression, Tokens endToken1, Tokens endToken2);

void Parameter_Declaration(Parser* ctx, TParameterDeclaration* pParameterDeclaration);

_Bool Declaration(Parser* ctx, TAnyDeclaration** ppDeclaration);

void Type_Qualifier_ListOpt(Parser* ctx, TTypeQualifier* pQualifier);

_Bool Declaration_Specifiers(Parser* ctx, TDeclarationSpecifiers* pDeclarationSpecifiers);

void Declarator(Parser* ctx, TDeclarator* pTDeclarator2);

_Bool Type_Specifier(Parser* ctx, TTypeSpecifier** ppTypeSpecifier, int* typedefCount);

_Bool Type_Qualifier(Parser* ctx, TTypeQualifier* pQualifier);

void Initializer(Parser* ctx,

	TInitializer** ppInitializer,

	Tokens endToken1,

	Tokens endToken2);





void Expression_Statement(Parser* ctx, TStatement** ppStatement)

{

	

	TExpressionStatement* pExpression = TExpressionStatement_Create();

	*ppStatement = (TStatement*)pExpression;

	Tokens token = Token(ctx);



	if (token != TK_SEMICOLON)

	{

		Expression0(ctx, &pExpression->pExpression);

	}



	MatchToken(ctx, TK_SEMICOLON);

}



void Selection_Statement(Parser* ctx, TStatement** ppStatement)

{

	

	Tokens token = Token(ctx);



	switch (token)

	{

		case TK_IF:

		{

			TIfStatement* pIfStatement = TIfStatement_Create();

			*ppStatement = (TStatement*)pIfStatement;

			Match(ctx);

			MatchToken(ctx, TK_LEFT_PARENTHESIS);

			

			

			Expression0(ctx, &pIfStatement->pConditionExpression);

			MatchToken(ctx, TK_RIGHT_PARENTHESIS);

			

			

			Statement(ctx, &pIfStatement->pStatement);

			token = Token(ctx);



			if (token == TK_ELSE)

			{

				Match(ctx);

				

				

				Statement(ctx, &pIfStatement->pElseStatement);

			}

		}

		break;



		case TK_SWITCH:

		{

			TSwitchStatement* pSelectionStatement = TSwitchStatement_Create();

			*ppStatement = (TStatement*)pSelectionStatement;

			Match(ctx);

			MatchToken(ctx, TK_LEFT_PARENTHESIS);

			

			

			Expression0(ctx, &pSelectionStatement->pConditionExpression);

			MatchToken(ctx, TK_RIGHT_PARENTHESIS);

			

			

			Statement(ctx, &pSelectionStatement->pExpression);

		}

		break;



		default:

			( void ) ( ( ! ! ( ( 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"0" ) ) || ( __debugbreak ( ) , 0 ) ) ;

			break;

	}

}



void Jump_Statement(Parser* ctx, TStatement** ppStatement)

{

	

	

	Tokens token = Token(ctx);



	switch (token)

	{

		case TK_GOTO:

		{

			TJumpStatement* pJumpStatement = TJumpStatement_Create();

			pJumpStatement->token = token;

			*ppStatement = (TStatement*)pJumpStatement;

			Match(ctx);

			MatchToken(ctx, TK_identifier);

		}

		break;



		case TK_CONTINUE:

		{

			TJumpStatement* pJumpStatement = TJumpStatement_Create();

			pJumpStatement->token = token;

			*ppStatement = (TStatement*)pJumpStatement;

			Match(ctx);

			MatchToken(ctx, TK_SEMICOLON);

		}

		break;



		case TK_BREAK:

		{

			TJumpStatement* pJumpStatement = TJumpStatement_Create();

			pJumpStatement->token = token;

			*ppStatement = (TStatement*)pJumpStatement;

			Match(ctx);

			MatchToken(ctx, TK_SEMICOLON);

		}

		break;



		case TK_RETURN:

		{

			TReturnStatement* pReturnStatement = TReturnStatement_Create();



			*ppStatement = (TStatement*)pReturnStatement;

			token = Match(ctx);



			if (token != TK_SEMICOLON)

			{

				Expression0(ctx, &pReturnStatement->pExpression);

			}



			MatchToken(ctx, TK_SEMICOLON);

		}

		break;



		default:

			( void ) ( ( ! ! ( ( 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"0" ) ) || ( __debugbreak ( ) , 0 ) ) ;

			break;

	}

}



void Iteration_Statement(Parser* ctx, TStatement** ppStatement)

{

	

	Tokens token = Token(ctx);



	switch (token)

	{

		case TK_WHILE:

		{

			TWhileStatement* pWhileStatement = TWhileStatement_Create();

			*ppStatement = (TStatement*)pWhileStatement;

			Match(ctx);

			MatchToken(ctx, TK_LEFT_PARENTHESIS);

			Expression0(ctx, &pWhileStatement->pExpression);

			MatchToken(ctx, TK_RIGHT_PARENTHESIS);

			Statement(ctx, &pWhileStatement->pStatement);

		}

		break;



		case TK_DO:

		{

			TDoStatement* pDoStatement = TDoStatement_Create();

			*ppStatement = (TStatement*)pDoStatement;

			Match(ctx);

			Statement(ctx, &pDoStatement->pStatement);

			MatchToken(ctx, TK_WHILE);

			MatchToken(ctx, TK_LEFT_PARENTHESIS);

			Expression0(ctx, &pDoStatement->pExpression);

			MatchToken(ctx, TK_RIGHT_PARENTHESIS);

			MatchToken(ctx, TK_SEMICOLON);

		}

		break;



		case TK_FOR:

		{

			TForStatement* pIterationStatement = TForStatement_Create();

			*ppStatement = (TStatement*)pIterationStatement;

			Match(ctx);

			token = MatchToken(ctx, TK_LEFT_PARENTHESIS);



			

			if (token != TK_SEMICOLON)

			{

				

				

				



				_Bool bHasDeclaration = Declaration(ctx, &pIterationStatement->pInitDeclarationOpt);



				if (bHasDeclaration)

				{

					token = Token(ctx);



					if (token != TK_SEMICOLON)

					{

						

						Expression0(ctx, &pIterationStatement->pExpression2);

						MatchToken(ctx, TK_SEMICOLON);

					}

					else

					{

						

						MatchToken(ctx, TK_SEMICOLON);

					}

				}



				else

				{

					token = Token(ctx);



					if (token != TK_SEMICOLON)

					{

						

						Expression0(ctx, &pIterationStatement->pExpression1);

						MatchToken(ctx, TK_SEMICOLON);

					}



					token = Token(ctx);



					if (token != TK_SEMICOLON)

					{

						

						Expression0(ctx, &pIterationStatement->pExpression2);

						MatchToken(ctx, TK_SEMICOLON);

					}



					else

					{

						

						MatchToken(ctx, TK_SEMICOLON);

					}



				}

			}



			else

			{

				

				MatchToken(ctx, TK_SEMICOLON);

				token = Token(ctx);



				if (token != TK_SEMICOLON)

				{

					

					Expression0(ctx, &pIterationStatement->pExpression2);

					MatchToken(ctx, TK_SEMICOLON);

				}



				else

				{

					

					MatchToken(ctx, TK_SEMICOLON);

				}

			}



			token = Token(ctx);



			

			if (token != TK_RIGHT_PARENTHESIS)

			{

				Expression0(ctx, &pIterationStatement->pExpression3);

			}



			MatchToken(ctx, TK_RIGHT_PARENTHESIS);

			Statement(ctx, &pIterationStatement->pStatement);

		}

		break;



		default:

			( void ) ( ( ! ! ( ( 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"0" ) ) || ( __debugbreak ( ) , 0 ) ) ;

			break;

	}

}





void Labeled_Statement(Parser* ctx, TStatement** ppStatement)

{

	

	TLabeledStatement* pLabeledStatement = TLabeledStatement_Create();

	*ppStatement = (TStatement*)pLabeledStatement;

	Tokens token = Token(ctx);

	pLabeledStatement->token = token;



	if (token == TK_identifier)

	{

		

		String_Set(&pLabeledStatement->Identifier, Lexeme(ctx));

		Match(ctx);

		MatchToken(ctx, TK_COLON);

		Statement(ctx, &pLabeledStatement->pStatementOpt);

	}



	else if (token == TK_case)

	{

		Match(ctx);

		ConstantExpression(ctx, &pLabeledStatement->pExpression);

		MatchToken(ctx, TK_COLON);

		Statement(ctx, &pLabeledStatement->pStatementOpt);				

	}



	else if (token == TK_DEFAULT)

	{

		Match(ctx);

		MatchToken(ctx, TK_COLON);

		Statement(ctx, &pLabeledStatement->pStatementOpt);

	}

}



void Asm_Statement(Parser* ctx, TStatement** ppStatement)

{

	

	TAsmStatement * pAsmStatement = TAsmStatement_Create();

	*ppStatement = (TStatement*)pAsmStatement;

	MatchToken(ctx, TK__Asm);

	Tokens token = Token(ctx);



	if (token == TK_LEFT_CURLY_BRACKET)

	{

		Match(ctx);



		for (; ;)

		{

			if (ErrorOrEof(ctx))

			{

				break;

			}



			token = Token(ctx);



			if (token == TK_RIGHT_CURLY_BRACKET)

			{

				Match(ctx);

				break;

			}



			Match(ctx);

		}

	}



	else

	{

		

		

		

		token = Token(ctx);



		for (; ;)

		{

			if (ErrorOrEof(ctx))

			{

				break;

			}



			token = Token(ctx);



			if (token == TK_RIGHT_CURLY_BRACKET)

			{

				

				

				

				

				break;

			}



			if (token == TK_SEMICOLON)

			{

				break;

			}



			Match(ctx);

		}

	}



	

	token = Token(ctx);



	if (token == TK_SEMICOLON)

	{

		Match(ctx);

	}

}



_Bool Statement(Parser* ctx, TStatement** ppStatement)

{

	( void ) ( ( ! ! ( ( * ppStatement == ( ( void * ) 0 ) ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"* ppStatement == ( ( void * ) 0 )" ) ) || ( __debugbreak ( ) , 0 ) ) ;



	if (HasErrors(ctx))

	{

		return 0 ;

	}



	_Bool bResult = 0 ;

	Tokens token = Token(ctx);

	const char * lexeme = Lexeme(ctx);



	switch (token)

	{

		case TK__Asm:

			bResult = 1 ;

			Asm_Statement(ctx, ppStatement);

			break;



		case TK_LEFT_CURLY_BRACKET:

		{

			bResult = 1 ;

			Compound_Statement(ctx, ppStatement);

		}

		break;



		case TK_case:

		case TK_DEFAULT:

			bResult = 1 ;

			Labeled_Statement(ctx, ppStatement);

			break;



		case TK_SWITCH:

			bResult = 1 ;

			Selection_Statement(ctx, ppStatement);

			break;



		case TK_IF:

			bResult = 1 ;

			Selection_Statement(ctx, ppStatement);

			break;



		case TK_ELSE:

			

			bResult = 1 ;

			Match(ctx); 

			

			

			break;



			

		case TK_WHILE:

		case TK_FOR:

		case TK_DO:

			bResult = 1 ;

			Iteration_Statement(ctx, ppStatement);

			break;



			

		case TK_GOTO:

		case TK_CONTINUE:

		case TK_BREAK:

		case TK_RETURN:

			bResult = 1 ;

			Jump_Statement(ctx, ppStatement);

			break;



			

			

		case TK_LEFT_PARENTHESIS:

		case TK_SEMICOLON:

		

		case TK_DECIMAL_INTEGER:

		case TK_FLOAT_NUMBER:

		case TK_string_literal:

		



		

		case TK_PLUSPLUS:

		case TK_MINUSMINUS:



		case TK_SIZEOF:



		

		case TK_AMPERSAND:

		case TK_ASTERISK:

		case TK_PLUS_SIGN:

		case TK_HYPHEN_MINUS:

		case TK_TILDE:

		case TK_EXCLAMATION_MARK:

			

		case TK_ANDAND: 



			bResult = 1 ;

			Expression_Statement(ctx, ppStatement);

			break;



		case TK_identifier:



			if (DeclarationsMap_IsTypeDef(&ctx->Symbols, lexeme))

			{

				

			}

			else

			{

				if (LookAheadToken(ctx) == TK_COLON)

				{

					

					Labeled_Statement(ctx, ppStatement);

				}



				else

				{

					Expression_Statement(ctx, ppStatement);

				}



				bResult = 1 ;

			}



			break;



		case TK_inline:

		case TK__Noreturn:

		case TK__Alignas:

		

		

		case TK_const:

		case TK_restrict:

		case TK_volatile:

		case TK__Atomic:

		

		case TK_QUESTION_MARK:

		case TK_CIRCUMFLEX_ACCENT:



		

		

		case TK_typedef:

		case TK_extern:

		case TK_static:

		case TK__Thread_local:

		case TK_auto:

		case TK_register:

		case TK_void:

		case TK_char:

		case TK_short:

		case TK_int:

		case TK_long:

		case TK_float:

		case TK_double:

		case TK_signed:

		case TK_unsigned:

		case TK__Bool:

		case TK__Complex:

		case TK_struct:

		case TK_union:

		case TK_enum:

			bResult = 0 ;

			break;



		default:

			( void ) ( ( ! ! ( ( 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"0" ) ) || ( __debugbreak ( ) , 0 ) ) ;

			

			

			

			break;

	}



	return bResult;

}



void Block_Item(Parser* ctx, TBlockItem** ppBlockItem)

{

	

	*ppBlockItem = ( ( void * ) 0 ) ;

	TStatement* pStatement = ( ( void * ) 0 ) ;



	if (Statement(ctx, &pStatement))

	{

		*ppBlockItem = (TAnyDeclaration*)pStatement;

		( void ) ( ( ! ! ( ( * ppBlockItem != ( ( void * ) 0 ) ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"* ppBlockItem != ( ( void * ) 0 )" ) ) || ( __debugbreak ( ) , 0 ) ) ;

	}



	else

	{

		TAnyDeclaration* pDeclaration;

		Declaration(ctx, &pDeclaration);

		*ppBlockItem = (TAnyDeclaration*)pDeclaration;

		( void ) ( ( ! ! ( ( * ppBlockItem != ( ( void * ) 0 ) ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"* ppBlockItem != ( ( void * ) 0 )" ) ) || ( __debugbreak ( ) , 0 ) ) ;

	}

}



void Block_Item_List(Parser* ctx, TBlockItemList* pBlockItemList)

{

	for (; ;)

	{

		if (ErrorOrEof(ctx))

			break;



		TBlockItem* pBlockItem = ( ( void * ) 0 ) ;

		Block_Item(ctx, &pBlockItem);

		TBlockItemList_Push(pBlockItemList, pBlockItem);

		Tokens token = Token(ctx);



		if (token == TK_RIGHT_CURLY_BRACKET)

		{

			

			break;

		}



		if (ErrorOrEof(ctx))

			break;

	}

}



void Compound_Statement(Parser* ctx, TStatement** ppStatement)

{

	

	TCompoundStatement* pCompoundStatement = TCompoundStatement_Create();

	*ppStatement = (TStatement*)pCompoundStatement;

	MatchToken(ctx, TK_LEFT_CURLY_BRACKET);

	Tokens token = Token(ctx);



	if (token != TK_RIGHT_CURLY_BRACKET)

	{

		Block_Item_List(ctx, &pCompoundStatement->BlockItemList);

	}



	MatchToken(ctx, TK_RIGHT_CURLY_BRACKET);

}



void Struct_Or_Union(Parser* ctx,

	TStructUnionSpecifier* pStructUnionSpecifier)

{

	

	Tokens token = Token(ctx);



	switch (token)

	{

		case TK_struct:

			pStructUnionSpecifier->bIsStruct = 1 ;

			Match(ctx);

			break;



		case TK_union:

			pStructUnionSpecifier->bIsStruct = 0 ;

			Match(ctx);

			break;



		default:

			( void ) ( ( ! ! ( ( 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"0" ) ) || ( __debugbreak ( ) , 0 ) ) ;

			break;

	}

}



void Static_Assert_Declaration(Parser* ctx, TStaticAssertDeclaration* pStaticAssertDeclaration)

{

	

	Tokens token = Token(ctx);



	if (token == TK__Static_assert)

	{

		Match(ctx);

		MatchToken(ctx, TK_LEFT_PARENTHESIS);



		ConstantExpression(ctx,

			&pStaticAssertDeclaration->pConstantExpression);



		MatchToken(ctx, TK_COMMA);

		MatchToken(ctx, TK_string_literal);

		MatchToken(ctx, TK_RIGHT_PARENTHESIS);

		MatchToken(ctx, TK_SEMICOLON);

	}

}



void Specifier_Qualifier_List(Parser* ctx,

	TTypeQualifier* pQualifiers,

	TTypeSpecifier** ppTypeSpecifier)

{

	

	int typdefcount = 0;

	for (; ;)

	{

		if (ErrorOrEof(ctx))

			break;



		if (Type_Specifier(ctx, ppTypeSpecifier, &typdefcount))

		{

		}

		else if (Type_Qualifier(ctx, pQualifiers))

		{

		}

		else

		{

			break;

		}

	}

}



void Struct_Declarator(Parser* ctx,



	TStructDeclarator* pTDeclarator2)

{

	

	Tokens token = Token(ctx);



	if (token == TK_COLON)

	{

		

		Match(ctx);

		TExpression2* p = ( ( void * ) 0 ) ;

		ConstantExpression(ctx, &p);

		TExpression2_Delete(p);

	}



	else

	{

		Declarator(ctx, pTDeclarator2);

		token = Token(ctx);



		if (token == TK_COLON)

		{

			Match(ctx);

			TExpression2* p = ( ( void * ) 0 ) ;

			ConstantExpression(ctx, &p);

			TExpression2_Delete(p);

		}



		else if (token == TK_EQUALS_SIGN)

		{

			

			

			Match(ctx);

			Initializer(ctx, &pTDeclarator2->pInitializer, TK_SEMICOLON, TK_SEMICOLON);

		}

	}

}



void Struct_Declarator_List(Parser* ctx,



	TStructDeclaratorList* pStructDeclarationList)

{

	

	TStructDeclarator* pTDeclarator2 = TDeclarator_Create();

	TDeclaratorList_Push(pStructDeclarationList, pTDeclarator2);

	Struct_Declarator(ctx, pTDeclarator2);



	for (; ;)

	{

		if (ErrorOrEof(ctx))

			break;



		Tokens token = Token(ctx);



		if (token == TK_COMMA)

		{

			Match(ctx);

			Struct_Declarator_List(ctx, pStructDeclarationList);

		}



		else if (token == TK_SEMICOLON)

		{

			break;

		}



		else

		{

			SetError(ctx, "Struct_Declarator_List unexpected");

			break;

		}

	}

}



void Struct_Declaration(Parser* ctx,

	TAnyStructDeclaration** ppStructDeclaration)

{

	

	Tokens token = Token(ctx);



	if (token != TK__Static_assert)

	{

		TStructDeclaration* pStructDeclarationBase = TStructDeclaration_Create();

		*ppStructDeclaration = (TAnyStructDeclaration*)pStructDeclarationBase;

		Specifier_Qualifier_List(ctx,

			&pStructDeclarationBase->Qualifier,

			&pStructDeclarationBase->pSpecifier);

		token = Token(ctx);



		if (token != TK_SEMICOLON)

		{

			Struct_Declarator_List(ctx,

				&pStructDeclarationBase->DeclaratorList);

			MatchToken(ctx, TK_SEMICOLON);

		}



		else

		{

			MatchToken(ctx, TK_SEMICOLON);

		}

	}



	else

	{

		TStaticAssertDeclaration* pStaticAssertDeclaration = TStaticAssertDeclaration_Create();

		*ppStructDeclaration = (TAnyStructDeclaration*)pStaticAssertDeclaration;

		Static_Assert_Declaration(ctx, pStaticAssertDeclaration);

	}

}



void Struct_Declaration_List(Parser* ctx,



	TStructDeclarationList* pStructDeclarationList)

{

	

	for (; ;)

	{

		if (ErrorOrEof(ctx))

			break;



		Tokens token = Token(ctx);



		if (token == TK_RIGHT_CURLY_BRACKET)

			break;



		TAnyStructDeclaration* pStructDeclaration = ( ( void * ) 0 ) ;

		Struct_Declaration(ctx, &pStructDeclaration);

		TStructDeclarationList_Push(pStructDeclarationList, pStructDeclaration);

	}

}



void Struct_Or_Union_Specifier(Parser* ctx,

	TStructUnionSpecifier* pStructUnionSpecifier)

{

	

	Struct_Or_Union(ctx, pStructUnionSpecifier);

	Tokens token0 = Token(ctx);

	const char* lexeme = Lexeme(ctx);



	if (token0 == TK_identifier)

	{

		String_Set(&pStructUnionSpecifier->Name, lexeme);

	}



	else

	{

		const char* name = GetName();

		String_Set(&pStructUnionSpecifier->Name, name);

	}



	

	Match(ctx);

	Tokens token1 = Token(ctx);



	if (token0 == TK_identifier)

	{

		

		if (token1 == TK_LEFT_CURLY_BRACKET)

		{

			Match(ctx);

			Struct_Declaration_List(ctx,

				&pStructUnionSpecifier->StructDeclarationList);

			MatchToken(ctx, TK_RIGHT_CURLY_BRACKET);

		}



		else

		{

			

		}

	}

	else if (token0 == TK_LEFT_CURLY_BRACKET)

	{

		

		

		Struct_Declaration_List(ctx, &pStructUnionSpecifier->StructDeclarationList);

		MatchToken(ctx, TK_RIGHT_CURLY_BRACKET);

	}



	else

	{

		SetError(ctx, "expected name or {");

	}

}



void Enumeration_Constant(Parser* ctx,

	TEnumerator* pEnumerator2)

{

	const char* lexeme = Lexeme(ctx);

	String_Set(&pEnumerator2->Name, lexeme);



	

	Map_Set(&ctx->EnumMap, lexeme, (void*)1);



	MatchToken(ctx, TK_identifier);

}



_Bool EnumeratorC(Parser* ctx, TEnumerator* pEnumerator2)

{

	

	_Bool bValueAssigned = 0 ;

	Enumeration_Constant(ctx, pEnumerator2);





	Tokens token = Token(ctx);



	if (token == TK_EQUALS_SIGN)

	{

		Match(ctx);

		ConstantExpression(ctx, &pEnumerator2->pExpression);

		bValueAssigned = 1 ;

	}



	return bValueAssigned;

}



void Enumerator_List(Parser* ctx,

	TEnumeratorList* pEnumeratorList2)

{

	

	int currentValue = 0;

	

	TEnumerator* pEnumerator2 = TEnumerator_Create();

	TEnumeratorList_Push(pEnumeratorList2, pEnumerator2);



	if (!EnumeratorC(ctx, pEnumerator2))

	{

		

		

		currentValue++;

	}



	else

	{

		

		

		

		currentValue++;

	}



	for (; ;)

	{

		if (ErrorOrEof(ctx))

			break;



		Tokens token = Token(ctx);



		if (token == TK_COMMA)

		{

			

			Match(ctx);

			token = Token(ctx);



			

			if (token != TK_RIGHT_CURLY_BRACKET)

			{

				TEnumerator* pEnumerator3 = TEnumerator_Create();

				TEnumeratorList_Push(pEnumeratorList2, pEnumerator3);



				if (!EnumeratorC(ctx, pEnumerator3))

				{

					

					

					currentValue++;

				}

			}

		}



		else

		{

			( void ) ( ( ! ! ( ( token == TK_RIGHT_CURLY_BRACKET ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"token == TK_RIGHT_CURLY_BRACKET" ) ) || ( __debugbreak ( ) , 0 ) ) ;

			

			break;

		}

	}

}



void Enum_Specifier(Parser* ctx, TEnumSpecifier* pEnumSpecifier2)

{

	

	MatchToken(ctx, TK_enum);

	Tokens token = Token(ctx);



	if (token == TK_identifier)

	{

		const char* lexeme = Lexeme(ctx);

		String_Set(&pEnumSpecifier2->Name, lexeme);

	}



	else

	{

		const char* name = GetName();

		String_Set(&pEnumSpecifier2->Name, name);

	}



	Match(ctx);



	if (token == TK_identifier)

	{

		

		token = Token(ctx);



		if (token == TK_LEFT_CURLY_BRACKET)

		{

			Match(ctx);

			Enumerator_List(ctx, &pEnumSpecifier2->EnumeratorList);

			MatchToken(ctx, TK_RIGHT_CURLY_BRACKET);

		}



		else

		{

			

			

		}

	}

	else if (token == TK_LEFT_CURLY_BRACKET)

	{

		

		Enumerator_List(ctx, &pEnumSpecifier2->EnumeratorList);

		MatchToken(ctx, TK_RIGHT_CURLY_BRACKET);

	}



	else

	{

		SetError(ctx, "expected enum name or {");

	}

}



_Bool Function_Specifier(Parser* ctx,

	TFunctionSpecifier* pFunctionSpecifier)

{

	

	_Bool bResult = 0 ;

	Tokens token = Token(ctx);



	switch (token)

	{

		case TK_inline:

			pFunctionSpecifier->bIsInline = 1 ;

			Match(ctx);

			bResult = 1 ;

			break;



		case TK__Noreturn:

			pFunctionSpecifier->bIsNoReturn = 1 ;

			Match(ctx);

			bResult = 1 ;

			break;



		default:

			break;

	}



	return bResult;

}



_Bool Storage_Class_Specifier(Parser* ctx,



	TStorageSpecifier* pStorageSpecifier)

{

	

	_Bool bResult = 0 ;

	Tokens token = Token(ctx);



	

	switch (token)

	{

		case TK_typedef:

			pStorageSpecifier->bIsTypedef = 1 ;

			Match(ctx);

			bResult = 1 ;

			break;



		case TK_extern:

			pStorageSpecifier->bIsExtern = 1 ;

			Match(ctx);

			bResult = 1 ;

			break;



		case TK_static:

			pStorageSpecifier->bIsStatic = 1 ;

			Match(ctx);

			bResult = 1 ;

			break;



		case TK__Thread_local:

			pStorageSpecifier->bIsThread_local = 1 ;

			Match(ctx);

			bResult = 1 ;

			break;



		case TK_auto:

			pStorageSpecifier->bIsAuto = 1 ;

			Match(ctx);

			bResult = 1 ;

			break;



		case TK_register:

			pStorageSpecifier->bIsRegister = 1 ;

			Match(ctx);

			bResult = 1 ;

			break;



		default:

			break;

	}



	return bResult;

}



void Parameter_List(Parser* ctx,

	TParameterList* pParameterList)

{

	

	Tokens token = Token(ctx);



	TParameterDeclaration* pParameter = TParameterDeclaration_Create();

	TParameterList_Push(pParameterList, pParameter);

	Parameter_Declaration(ctx, pParameter);



	

	token = Token(ctx);

	if (token == TK_COMMA)

	{

		Match(ctx);

		Parameter_List(ctx, pParameterList);

	}

}







void AbstractDeclarator(Parser* ctx, TDeclarator* pTDeclarator2)

{

	

	

	Declarator(ctx, pTDeclarator2);

}



_Bool AbstractDeclaratorOpt(Parser* ctx, TDeclarator* pTDeclarator2)

{

	_Bool bResult = 0 ;

	Tokens token = Token(ctx);



	switch (token)

	{

		case TK_ASTERISK:

			AbstractDeclarator(ctx, pTDeclarator2);

			break;

	}



	return bResult;

}





void DirectAbstractDeclarator(Parser* ctx)

{

	( void ) ( ( ! ! ( ( 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"0" ) ) || ( __debugbreak ( ) , 0 ) ) ;

	



	Tokens token = Token(ctx);



	switch (token)

	{

		case TK_LEFT_PARENTHESIS:

			

			break;



		case TK_LEFT_SQUARE_BRACKET:



			break;

	}

}





void Parameter_Declaration(Parser* ctx,

	TParameterDeclaration* pParameterDeclaration)

{

	

	Declaration_Specifiers(ctx,

		&pParameterDeclaration->Specifiers);



	AbstractDeclarator(ctx, &pParameterDeclaration->Declarator);

}



void Parameter_Type_List(Parser* ctx,

	TParameterList* pParameterList)

{

	

	

	Parameter_List(ctx, pParameterList);

	Tokens token = Token(ctx);



	if (token == TK_DOTDOTDOT)

	{

		

		Match(ctx);

	}

}



void Direct_DeclaratorCore(Parser* ctx, TDeclarator* pDeclarator2)

{



	



	if (ErrorOrEof(ctx))

		return;





	



	Tokens token = Token(ctx);

	switch (token)

	{

		case TK_LEFT_SQUARE_BRACKET:

		{

			

			pDeclarator2->token = token;

			token = MatchToken(ctx, TK_LEFT_SQUARE_BRACKET);

			if (token == TK_static)

			{

			}

			else

			{

				( void ) ( ( ! ! ( ( pDeclarator2 -> pExpression == ( ( void * ) 0 ) ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"pDeclarator2 -> pExpression == ( ( void * ) 0 )" ) ) || ( __debugbreak ( ) , 0 ) ) ;

				AssignmentExpression(ctx, &pDeclarator2->pExpression);

			}



			MatchToken(ctx, TK_RIGHT_SQUARE_BRACKET);



		}

		break;

		case TK_LEFT_PARENTHESIS:

		{

			

			pDeclarator2->token = token;

			( void ) ( ( ! ! ( ( pDeclarator2 -> pParametersOpt == ( ( void * ) 0 ) ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"pDeclarator2 -> pParametersOpt == ( ( void * ) 0 )" ) ) || ( __debugbreak ( ) , 0 ) ) ;

			pDeclarator2->pParametersOpt = TParameterList_Create();

			token = MatchToken(ctx, TK_LEFT_PARENTHESIS);



			if (token != TK_RIGHT_PARENTHESIS)

			{

				

				Parameter_Type_List(ctx, pDeclarator2->pParametersOpt);

			}

			MatchToken(ctx, TK_RIGHT_PARENTHESIS);



		}break;

	}



	



	token = Token(ctx);

	switch (token)

	{

		case TK_LEFT_SQUARE_BRACKET:

			( void ) ( ( ! ! ( ( pDeclarator2 -> pDeclaratorOpt == ( ( void * ) 0 ) ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"pDeclarator2 -> pDeclaratorOpt == ( ( void * ) 0 )" ) ) || ( __debugbreak ( ) , 0 ) ) ;

			pDeclarator2->pDeclaratorOpt = TDeclarator_Create();

			Direct_DeclaratorCore(ctx, pDeclarator2->pDeclaratorOpt);

			break;

		case TK_LEFT_PARENTHESIS:

		{

			Tokens token2 = LookAheadToken(ctx);

			if (token2 == TK_ASTERISK)

			{

				( void ) ( ( ! ! ( ( 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"0" ) ) || ( __debugbreak ( ) , 0 ) ) ; 

				MatchToken(ctx, TK_LEFT_PARENTHESIS);

				Declarator(ctx, pDeclarator2);

				MatchToken(ctx, TK_RIGHT_PARENTHESIS);

			}

			else

			{

				( void ) ( ( ! ! ( ( pDeclarator2 -> pDeclaratorOpt == ( ( void * ) 0 ) ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"pDeclarator2 -> pDeclaratorOpt == ( ( void * ) 0 )" ) ) || ( __debugbreak ( ) , 0 ) ) ;

				pDeclarator2->pDeclaratorOpt = TDeclarator_Create();

				Direct_DeclaratorCore(ctx, pDeclarator2->pDeclaratorOpt);

			}

		}	break;



	}

}



void Direct_Declarator(Parser* ctx, TDeclarator* pDeclarator2)

{

	





	if (ErrorOrEof(ctx))

		return;







	Tokens token = Token(ctx);



	switch (token)

	{

		case TK_LEFT_PARENTHESIS:

		{

			

			MatchToken(ctx, TK_LEFT_PARENTHESIS);

			

			

			Declarator(ctx, pDeclarator2);

			

			pDeclarator2->token = token;

			

			MatchToken(ctx, TK_RIGHT_PARENTHESIS);



		}

		break;



		case TK_identifier:

		{

			

			pDeclarator2->token = token;

			const char* lexeme = Lexeme(ctx);

			String_Set(&pDeclarator2->Name, lexeme);

			Match(ctx);



		}  break;

	}



	



	token = Token(ctx);

	switch (token)

	{

		case TK_LEFT_PARENTHESIS:

		case TK_LEFT_SQUARE_BRACKET:

			( void ) ( ( ! ! ( ( pDeclarator2 -> pDeclaratorOpt == ( ( void * ) 0 ) ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"pDeclarator2 -> pDeclaratorOpt == ( ( void * ) 0 )" ) ) || ( __debugbreak ( ) , 0 ) ) ;

			pDeclarator2->pDeclaratorOpt = TDeclarator_Create();

			Direct_DeclaratorCore(ctx, pDeclarator2->pDeclaratorOpt);

			break;

	}



}



_Bool Type_Qualifier(Parser* ctx, TTypeQualifier* pQualifier)

{

	

	_Bool bResult = 0 ;

	Tokens token = Token(ctx);



	

	switch (token)

	{

		

		



		case TK_const:

			pQualifier->bIsConst = 1 ;

			Match(ctx);

			bResult = 1 ;

			break;



		case TK_restrict:

			pQualifier->bIsRestrict = 1 ;

			Match(ctx);

			bResult = 1 ;

			break;



		case TK_volatile:

			pQualifier->bIsVolatile = 1 ;

			Match(ctx);

			bResult = 1 ;

			break;



		case TK__Atomic:

			pQualifier->bIsAtomic = 1 ;

			Match(ctx);

			bResult = 1 ;

			break;

		

			

		case TK_QUESTION_MARK:

			pQualifier->bIsOpt = 1 ;

			Match(ctx);

			bResult = 1 ;

			break;

		case TK_CIRCUMFLEX_ACCENT:

			pQualifier->bIsOwner = 1 ;

			Match(ctx);

			bResult = 1 ;

			break;

		

		default:

			break;

	}



	return bResult;

}



void Type_Qualifier_ListOpt(Parser* ctx,

	TTypeQualifier* pQualifiers)

{

	

	while (Type_Qualifier(ctx, pQualifiers))

	{

	}

}



int PointerOpt(Parser* ctx, TPointerList* pPointerList)

{

	

	

	int ns = 0;

	

	Tokens token = Token(ctx);



	while (IsTypeQualifierToken(token) ||

		   token == TK_ASTERISK)   

	{

		TPointer* pPointer = TPointer_Create();

		TPointerList_Push(pPointerList, pPointer);

		

		if (IsTypeQualifierToken(token))			

		{

			Type_Qualifier_ListOpt(ctx, &pPointer->Qualifier);

		}

		else if (token == TK_ASTERISK)

		{

			Match(ctx);

		}



		token = Token(ctx);

		ns++;

	}



	

	return ns;

}





void Declarator(Parser* ctx, TDeclarator* pTDeclarator2)

{

	

	PointerOpt(ctx, &pTDeclarator2->PointerList);



	Direct_Declarator(ctx, pTDeclarator2);

}





_Bool Alignment_Specifier(Parser* ctx,

	TAlignmentSpecifier* pAlignmentSpecifier)

{

	_Bool bResult = 0 ;

	

	Tokens token = Token(ctx);



	if (token == TK__Alignas)

	{

		MatchToken(ctx, TK_LEFT_PARENTHESIS);

		( void ) ( ( ! ! ( ( 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"0" ) ) || ( __debugbreak ( ) , 0 ) ) ;

		MatchToken(ctx, TK_RIGHT_PARENTHESIS);

		bResult = 1 ;

	}



	return bResult;

}



_Bool Type_Specifier(Parser* ctx,

	TTypeSpecifier** ppTypeSpecifier, int *typedefCount)

{

	

	TSingleTypeSpecifier* pSingleTypeSpecifier = ( ( void * ) 0 ) ;



	if (*ppTypeSpecifier != ( ( void * ) 0 ) )

	{

		if ((*ppTypeSpecifier)->type == TSingleTypeSpecifier_ID)

		{

			pSingleTypeSpecifier = (TSingleTypeSpecifier*)(*ppTypeSpecifier);

		}



		else

		{

			

		}

	}



	_Bool bResult = 0 ;

	const char* lexeme = Lexeme(ctx);

	Tokens token = Token(ctx);



	switch (token)

	{

		

		case TK_void:

		{

			if (pSingleTypeSpecifier == ( ( void * ) 0 ) )

			{

				pSingleTypeSpecifier = TSingleTypeSpecifier_Create();

			}



			pSingleTypeSpecifier->bIsVoid = 1 ;

			bResult = 1 ;

			Match(ctx);

			*ppTypeSpecifier = (TTypeSpecifier*)pSingleTypeSpecifier;

		}

		break;



		case TK_char:

		{

			if (pSingleTypeSpecifier == ( ( void * ) 0 ) )

			{

				pSingleTypeSpecifier = TSingleTypeSpecifier_Create();

			}



			pSingleTypeSpecifier->bIsChar = 1 ;

			bResult = 1 ;

			Match(ctx);

			*ppTypeSpecifier = (TTypeSpecifier*)pSingleTypeSpecifier;

		}

		break;



		case TK_short:

		{

			if (pSingleTypeSpecifier == ( ( void * ) 0 ) )

			{

				pSingleTypeSpecifier = TSingleTypeSpecifier_Create();

			}



			pSingleTypeSpecifier->bIsShort = 1 ;

			bResult = 1 ;

			Match(ctx);

			*ppTypeSpecifier = (TTypeSpecifier*)pSingleTypeSpecifier;

		}

		break;



		case TK_int:

		{

			if (pSingleTypeSpecifier == ( ( void * ) 0 ) )

			{

				pSingleTypeSpecifier = TSingleTypeSpecifier_Create();

			}



			pSingleTypeSpecifier->bIsInt = 1 ;

			bResult = 1 ;

			Match(ctx);

			*ppTypeSpecifier = (TTypeSpecifier*)pSingleTypeSpecifier;

		}

		break;



		case TK_long:

		{

			if (pSingleTypeSpecifier == ( ( void * ) 0 ) )

			{

				pSingleTypeSpecifier = TSingleTypeSpecifier_Create();

			}



			pSingleTypeSpecifier->nLong++;

			bResult = 1 ;

			Match(ctx);

			*ppTypeSpecifier = (TTypeSpecifier*)pSingleTypeSpecifier;

		}

		break;



		case TK_float:

		{

			if (pSingleTypeSpecifier == ( ( void * ) 0 ) )

			{

				pSingleTypeSpecifier = TSingleTypeSpecifier_Create();

			}



			pSingleTypeSpecifier->bIsFloat = 1 ;

			bResult = 1 ;

			Match(ctx);

			*ppTypeSpecifier = (TTypeSpecifier*)pSingleTypeSpecifier;

		}

		break;



		case TK_double:

		{

			if (pSingleTypeSpecifier == ( ( void * ) 0 ) )

			{

				pSingleTypeSpecifier = TSingleTypeSpecifier_Create();

			}



			pSingleTypeSpecifier->bIsDouble = 1 ;

			bResult = 1 ;

			Match(ctx);

			*ppTypeSpecifier = (TTypeSpecifier*)pSingleTypeSpecifier;

		}

		break;



		case TK_signed:

		{

			if (pSingleTypeSpecifier == ( ( void * ) 0 ) )

			{

				pSingleTypeSpecifier = TSingleTypeSpecifier_Create();

			}



			pSingleTypeSpecifier->bIsSigned = 1 ;

			bResult = 1 ;

			Match(ctx);

			*ppTypeSpecifier = (TTypeSpecifier*)pSingleTypeSpecifier;

		}

		break;



		case TK_unsigned:

		{

			if (pSingleTypeSpecifier == ( ( void * ) 0 ) )

			{

				pSingleTypeSpecifier = TSingleTypeSpecifier_Create();

			}



			pSingleTypeSpecifier->bIsUnsigned = 1 ;

			bResult = 1 ;

			Match(ctx);

			*ppTypeSpecifier = (TTypeSpecifier*)pSingleTypeSpecifier;

		}

		break;



		case TK__Bool:

		{

			if (pSingleTypeSpecifier == ( ( void * ) 0 ) )

			{

				pSingleTypeSpecifier = TSingleTypeSpecifier_Create();

			}



			pSingleTypeSpecifier->bIsBool = 1 ;

			bResult = 1 ;

			Match(ctx);

			*ppTypeSpecifier = (TTypeSpecifier*)pSingleTypeSpecifier;

		}

		break;



		case TK__Complex:

		{

			if (pSingleTypeSpecifier == ( ( void * ) 0 ) )

			{

				pSingleTypeSpecifier = TSingleTypeSpecifier_Create();

			}



			pSingleTypeSpecifier->bIsComplex = 1 ;

			bResult = 1 ;

			Match(ctx);

			*ppTypeSpecifier = (TTypeSpecifier*)pSingleTypeSpecifier;

		}

		break;



		

		case TK_struct:

		case TK_union:

		{

			( void ) ( ( ! ! ( ( * ppTypeSpecifier == ( ( void * ) 0 ) ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"* ppTypeSpecifier == ( ( void * ) 0 )" ) ) || ( __debugbreak ( ) , 0 ) ) ;

			bResult = 1 ;

			TStructUnionSpecifier* pStructUnionSpecifier = TStructUnionSpecifier_Create();

			*ppTypeSpecifier = (TTypeSpecifier*)pStructUnionSpecifier;

			Struct_Or_Union_Specifier(ctx, pStructUnionSpecifier);

		}

		break;



		case TK_enum:

		{

			( void ) ( ( ! ! ( ( * ppTypeSpecifier == ( ( void * ) 0 ) ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"* ppTypeSpecifier == ( ( void * ) 0 )" ) ) || ( __debugbreak ( ) , 0 ) ) ;

			bResult = 1 ;

			TEnumSpecifier* pEnumSpecifier2 = TEnumSpecifier_Create();

			*ppTypeSpecifier = (TTypeSpecifier*)pEnumSpecifier2;

			Enum_Specifier(ctx, pEnumSpecifier2);

		}

		break;



		case TK_identifier:

		{

			_Bool bIsTypedef = DeclarationsMap_IsTypeDef(&ctx->Symbols, lexeme);



			if (bIsTypedef && *typedefCount == 0)

			{

				*typedefCount = 1;



				if (pSingleTypeSpecifier == ( ( void * ) 0 ) )

				{

					pSingleTypeSpecifier = TSingleTypeSpecifier_Create();

				}



				pSingleTypeSpecifier->bIsTypeDef = 1 ;

				String_Set(&pSingleTypeSpecifier->TypedefName, lexeme);

				bResult = 1 ;

				Match(ctx);

				*ppTypeSpecifier = (TTypeSpecifier*)pSingleTypeSpecifier;

			}



			else

			{

				bResult = 0 ;

			}

		}

		break;



		default:

			break;

	}



	

	

	return bResult;

}



_Bool Declaration_Specifiers(Parser* ctx,

	TDeclarationSpecifiers* pDeclarationSpecifiers)

{

	

	_Bool bResult = 0 ;

	int typedefCount = 0;

	

	for (; ;)

	{

		if (ErrorOrEof(ctx))

			break;



		if (Type_Specifier(ctx, &pDeclarationSpecifiers->pTypeSpecifierOpt, &typedefCount) ||

			Storage_Class_Specifier(ctx, &pDeclarationSpecifiers->StorageSpecifiers) ||

			Type_Qualifier(ctx, &pDeclarationSpecifiers->TypeQualifiers) ||

			Function_Specifier(ctx, &pDeclarationSpecifiers->FunctionSpecifiers) ||

			Alignment_Specifier(ctx, &pDeclarationSpecifiers->AlignmentSpecifier))

		{

			bResult = 1 ; 

			continue;

		}



		else

		{

			break;

		}

	}



	return bResult;

}







void Initializer(Parser* ctx,

	TInitializer** ppInitializer,

	Tokens endToken1,

	Tokens endToken2)

{

	( void ) ( ( ! ! ( ( * ppInitializer == ( ( void * ) 0 ) ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"* ppInitializer == ( ( void * ) 0 )" ) ) || ( __debugbreak ( ) , 0 ) ) ;

	

	Tokens token = Token(ctx);



	if (token == TK_LEFT_CURLY_BRACKET)

	{

		TInitializerListType* pTInitializerList = TInitializerListType_Create();

		*ppInitializer = (TInitializer*)pTInitializerList;

		Match(ctx);

		Initializer_List(ctx, &pTInitializerList->InitializerList);

		MatchToken(ctx, TK_RIGHT_CURLY_BRACKET);

	}



	else

	{

		TExpression2* pExpression = ( ( void * ) 0 ) ;

		AssignmentExpression(ctx, &pExpression);

		*ppInitializer = (TInitializer*)pExpression;

	}

}



void Initializer_List(Parser* ctx, TInitializerList* pInitializerList)

{

	

	for (; ;)

	{

		if (ErrorOrEof(ctx))

			break;



		TInitializerListItem* pTInitializerListItem = TInitializerListItem_Create();

		TInitializerList_Push(pInitializerList, pTInitializerListItem);

		Tokens token = Token(ctx);



		if (token == TK_LEFT_SQUARE_BRACKET ||

			token == TK_FULL_STOP)

		{

			pTInitializerListItem->pDesignatorList = TDesignatorList_Create();

			Designation(ctx, pTInitializerListItem->pDesignatorList);

		}



		Initializer(ctx, &pTInitializerListItem->pInitializer, TK_COMMA, TK_RIGHT_CURLY_BRACKET);

		

		token = Token(ctx);



		if (token == TK_COMMA)

		{

			Match(ctx);

			

		}



		else

		{

			break;

		}

	}

}



void Designation(Parser* ctx, TDesignatorList* pDesignatorList)

{

	

	Designator_List(ctx, pDesignatorList);

	MatchToken(ctx, TK_EQUALS_SIGN);

}



void Designator_List(Parser* ctx, TDesignatorList* pDesignatorList)

{

	

	

	TDesignator* pDesignator = TDesignator_Create();

	Designator(ctx, pDesignator);

	TDesignatorList_Push(pDesignatorList, pDesignator);



	for (; ;)

	{

		if (ErrorOrEof(ctx))

			break;



		Tokens token = Token(ctx);



		if (token == TK_LEFT_SQUARE_BRACKET ||

			token == TK_FULL_STOP)

		{

			TDesignator* pDesignatorNew = TDesignator_Create();

			Designator(ctx, pDesignatorNew);

			TDesignatorList_Push(pDesignatorList, pDesignatorNew);

		}



		else

		{

			break;

		}

	}

}



void Designator(Parser* ctx, TDesignator* p)

{

	

	Tokens token = Token(ctx);



	if (token == TK_LEFT_SQUARE_BRACKET)

	{

		Match(ctx);

		ConstantExpression(ctx, &p->pExpression);

		MatchToken(ctx, TK_RIGHT_SQUARE_BRACKET);

	}



	else if (token == TK_FULL_STOP)

	{

		Match(ctx);

		String_Set(&p->Name, Lexeme(ctx));

		MatchToken(ctx, TK_identifier);

	}

}



void Init_Declarator(Parser* ctx,

	TDeclarator* pDeclarator2)

{

	

	Declarator(ctx, pDeclarator2);

	Tokens token = Token(ctx);



	if (token == TK_EQUALS_SIGN)

	{

		Match(ctx);

		Initializer(ctx, &pDeclarator2->pInitializer, TK_SEMICOLON, TK_SEMICOLON);

	}

}



void Init_Declarator_List(Parser* ctx,



	TDeclaratorList* pDeclaratorList2)

{

	

	TDeclarator* pDeclarator2 = TDeclarator_Create();

	TDeclaratorList_Push(pDeclaratorList2, pDeclarator2);

	Init_Declarator(ctx, pDeclarator2);



	

	Tokens token = Token(ctx);

	if (token == TK_COMMA)

	{

		Match(ctx);

		Init_Declarator_List(ctx, pDeclaratorList2);

	}



}



_Bool Declaration(Parser* ctx,

	TAnyDeclaration** ppDeclaration)

{

	



	_Bool bHasDeclaration = 0 ;

	Tokens token = Token(ctx);



	if (token == TK__Static_assert)

	{

		TStaticAssertDeclaration* pStaticAssertDeclaration = TStaticAssertDeclaration_Create();

		*ppDeclaration = (TAnyDeclaration*)pStaticAssertDeclaration;

		Static_Assert_Declaration(ctx, pStaticAssertDeclaration);

		bHasDeclaration = 1 ;

	}



	else

	{

		TDeclaration* pFuncVarDeclaration = TDeclaration_Create();



		if (token == TK_SEMICOLON)

		{

			

			bHasDeclaration = 0 ;

			Match(ctx);

		}



		else

		{

			bHasDeclaration =

				Declaration_Specifiers(ctx, &pFuncVarDeclaration->Specifiers);

		}



		*ppDeclaration = (TAnyDeclaration*)pFuncVarDeclaration;

		pFuncVarDeclaration->FileIndex = GetFileIndex(ctx);

		pFuncVarDeclaration->Line = GetCurrentLine(ctx);

		( void ) ( ( ! ! ( ( pFuncVarDeclaration -> FileIndex >= 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2 , L"__FILE__" , 0 , ( ( void * ) 0 ) , L"%ls" , L"pFuncVarDeclaration -> FileIndex >= 0" ) ) || ( __debugbreak ( ) , 0 ) ) ;



		if (bHasDeclaration)

		{

			token = Token(ctx);



			if (token == TK_SEMICOLON)

			{

				Match(ctx);

			}



			else

			{

				

				Init_Declarator_List(ctx, &pFuncVarDeclaration->Declarators);

				token = Token(ctx);



				if (token == TK_LEFT_CURLY_BRACKET)

				{

					TStatement* pStatement;

					Compound_Statement(ctx, &pStatement);

					

					pFuncVarDeclaration->pCompoundStatementOpt = (TCompoundStatement*)pStatement;

				}



				else

				{

					MatchToken(ctx, TK_SEMICOLON);

				}

			}

		}

	}



	return bHasDeclaration;

}



void SetSymbolsFromDeclaration(Parser* ctx,



	TAnyDeclaration* pDeclaration2)

{

	

	if (pDeclaration2->type == TDeclaration_ID)

	{

		TDeclaration* pTFuncVarDeclaration = (TDeclaration*)pDeclaration2;

		

		{



			for (size_t i = 0; i < pTFuncVarDeclaration->Declarators.size; i++)

			{

				TDeclarator* pDeclarator = pTFuncVarDeclaration->Declarators.pItems[i];

				const char* declaratorName = TDeclarator_FindName(pDeclarator);



				if (declaratorName == ( ( void * ) 0 ) )

				{

					

					

					

				}

				else

				{

					Parser_SetSymbol(ctx, declaratorName, pDeclaration2);

				}

			}

		}

	}

}



void Parse_Declarations(Parser* ctx, TDeclarations* declarations)

{

	int declarationIndex = 0;



	while (!ErrorOrEof(ctx))

	{

		TAnyDeclaration* pDeclarationOut = ( ( void * ) 0 ) ;

		Declaration(ctx, &pDeclarationOut);

		TDeclarations_Push(declarations, pDeclarationOut);

		declarationIndex++;



		if (HasErrors(ctx))

			break;



		SetSymbolsFromDeclaration(ctx, pDeclarationOut);

	}

}



void Parser_Main(Parser* ctx, TDeclarations* declarations)

{

	Parse_Declarations(ctx, declarations);

}



static void TFileMapToStrArray(TFileMap* map, TFileArray* arr)

{

	TFileArray_Reserve(arr, map->Size);

	arr->size = map->Size;



	for (size_t i = 0; i < map->buckets.size; i++)

	{

		Bucket* data = map->buckets.data[i];



		if (data != ( ( void * ) 0 ) )

		{

			for (size_t k = 0; k < data->size; k++)

			{

				BucketItem* node = data->data[k];

				TFile* pFile = (TFile*)node->data;



				if (pFile->FileIndex >= 0 &&

					pFile->FileIndex < (int)arr->size)

				{

					arr->pItems[pFile->FileIndex] = pFile;

					node->data = ( ( void * ) 0 ) ; 

				}

			}

		}

	}

}



_Bool GetAST(const char* filename,

	const char* configFileName,

	TProgram* pProgram)

{

	_Bool bResult = 0 ;

	String fullFileNamePath = ( ( void * ) 0 ) ;

	GetFullPath(filename, &fullFileNamePath);

	String fullConfigFilePath = ( ( void * ) 0 ) ;

	GetFullPath(configFileName, &fullConfigFilePath);



	Parser parser;

	Parser_InitFile(&parser, fullConfigFilePath);

	Parser_Main(&parser, &pProgram->Declarations);



	

	if (filename != ( ( void * ) 0 ) )

	{

		Parser_PushFile(&parser, fullFileNamePath);

		Parser_Main(&parser, &pProgram->Declarations);

	}



	TFileMapToStrArray(&parser.Scanner.FilesIncluded, &pProgram->Files2);

	printf("%s\n", GetCompletationMessage(&parser));

	MultiMap_Swap(&parser.Symbols, &pProgram->Symbols);



	TMacroMap_Swap(&parser.Scanner.Defines, &pProgram->Defines);

	Map_Swap(&parser.EnumMap, &pProgram->EnumMap);



	bResult = !parser.bError;



	Parser_Destroy(&parser);

	String_Destroy(&fullFileNamePath);

	String_Destroy(&fullConfigFilePath);

	return bResult;

}

















